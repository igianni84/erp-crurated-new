<?php

namespace App\Services\Finance;

use App\Enums\Finance\InvoiceStatus;
use App\Enums\Finance\InvoiceType;
use App\Models\AuditLog;
use App\Models\Customer\Customer;
use App\Models\Finance\Invoice;
use App\Models\Finance\InvoiceLine;
use App\Models\Finance\InvoicePayment;
use App\Models\Finance\Payment;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use InvalidArgumentException;

/**
 * Service for managing Invoice lifecycle and operations.
 *
 * Centralizes all invoice business logic including creation, issuance,
 * payment application, and status management.
 *
 * Finance is consequence, not cause - invoices are generated by other modules
 * but managed through this service.
 */
class InvoiceService
{
    /**
     * Create a draft invoice.
     *
     * Creates a new invoice in draft status that can be edited until issued.
     * Invoice type is locked at creation and cannot be changed.
     *
     * @param  InvoiceType  $invoiceType  The type of invoice (INV0-INV4)
     * @param  Customer  $customer  The customer for this invoice
     * @param  array<int, array{description: string, quantity: string|float, unit_price: string|float, tax_rate?: string|float, tax_amount?: string|float, sellable_sku_id?: int|null, metadata?: array<string, mixed>}>  $lines  Invoice lines
     * @param  string|null  $sourceType  The type of source entity (subscription, voucher_sale, etc.)
     * @param  int|null  $sourceId  The ID of the source entity
     * @param  string  $currency  Currency code (default: EUR)
     * @param  Carbon|null  $dueDate  Optional due date
     * @param  string|null  $notes  Optional notes
     *
     * @throws InvalidArgumentException If validation fails or duplicate source exists
     */
    public function createDraft(
        InvoiceType $invoiceType,
        Customer $customer,
        array $lines,
        ?string $sourceType = null,
        ?int $sourceId = null,
        string $currency = 'EUR',
        ?Carbon $dueDate = null,
        ?string $notes = null
    ): Invoice {
        // Validate source reference requirements
        $this->validateSourceReference($invoiceType, $sourceType, $sourceId);

        // Validate currency is supported
        $this->validateCurrency($currency);

        // Check for duplicate invoice for same source (idempotency)
        if ($sourceType !== null && $sourceId !== null) {
            $existing = $this->findBySource($sourceType, $sourceId);
            if ($existing !== null) {
                return $existing;
            }
        }

        return DB::transaction(function () use ($invoiceType, $customer, $lines, $sourceType, $sourceId, $currency, $dueDate, $notes): Invoice {
            // Create the invoice
            $invoice = Invoice::create([
                'invoice_type' => $invoiceType,
                'customer_id' => $customer->id,
                'currency' => $currency,
                'status' => InvoiceStatus::Draft,
                'source_type' => $sourceType,
                'source_id' => $sourceId,
                'due_date' => $dueDate,
                'notes' => $notes,
                'subtotal' => '0.00',
                'tax_amount' => '0.00',
                'total_amount' => '0.00',
                'amount_paid' => '0.00',
            ]);

            // Add lines and calculate totals
            $this->addLines($invoice, $lines);

            // Log creation
            $this->logInvoiceEvent(
                $invoice,
                AuditLog::EVENT_CREATED,
                [],
                [
                    'invoice_type' => $invoiceType->value,
                    'customer_id' => $customer->id,
                    'source_type' => $sourceType,
                    'source_id' => $sourceId,
                    'total_amount' => $invoice->total_amount,
                ]
            );

            return $invoice->fresh();
        });
    }

    /**
     * Issue a draft invoice.
     *
     * Transitions draft to issued, generates sequential invoice_number,
     * sets issued_at, and makes lines immutable.
     *
     * @throws InvalidArgumentException If invoice is not in draft status or validation fails
     */
    public function issue(Invoice $invoice): Invoice
    {
        if (! $invoice->isDraft()) {
            throw new InvalidArgumentException(
                "Cannot issue invoice: invoice is not in draft status. Current status: {$invoice->status->label()}"
            );
        }

        // Validate invoice has at least one line
        if ($invoice->invoiceLines()->count() === 0) {
            throw new InvalidArgumentException(
                'Cannot issue invoice: invoice must have at least one line item.'
            );
        }

        // Validate total amount is positive
        if (bccomp($invoice->total_amount, '0', 2) <= 0) {
            throw new InvalidArgumentException(
                'Cannot issue invoice: total amount must be greater than zero.'
            );
        }

        // Validate due date requirements
        if ($invoice->invoice_type->requiresDueDate() && $invoice->due_date === null) {
            throw new InvalidArgumentException(
                "Cannot issue invoice: due date is required for {$invoice->invoice_type->label()} invoices."
            );
        }

        return DB::transaction(function () use ($invoice): Invoice {
            $oldStatus = $invoice->status;

            // Generate invoice number
            $invoiceNumber = $this->generateInvoiceNumber();

            // Update invoice
            $invoice->invoice_number = $invoiceNumber;
            $invoice->status = InvoiceStatus::Issued;
            $invoice->issued_at = now();

            // Capture FX rate at issuance for non-EUR currencies
            if ($invoice->currency !== 'EUR') {
                $invoice->fx_rate_at_issuance = $this->getFxRateForCurrency($invoice->currency);
            }

            // Set default due date if not set and applicable
            if ($invoice->due_date === null) {
                $defaultDays = $invoice->invoice_type->defaultDueDateDays();
                if ($defaultDays !== null) {
                    $invoice->due_date = now()->addDays($defaultDays);
                }
            }

            $invoice->save();

            // Log the issuance
            $this->logInvoiceEvent(
                $invoice,
                AuditLog::EVENT_STATUS_CHANGE,
                [
                    'status' => $oldStatus->value,
                    'invoice_number' => null,
                    'issued_at' => null,
                ],
                [
                    'status' => InvoiceStatus::Issued->value,
                    'invoice_number' => $invoiceNumber,
                    'issued_at' => $invoice->issued_at->toIso8601String(),
                    'due_date' => $invoice->due_date?->toDateString(),
                ]
            );

            // TODO: Trigger Xero sync event (US-E098)
            // event(new InvoiceIssued($invoice));

            return $invoice;
        });
    }

    /**
     * Apply a payment to an invoice.
     *
     * Creates an InvoicePayment record linking the payment to the invoice.
     * Updates invoice amount_paid and status accordingly.
     *
     * @param  string  $amount  The amount to apply from the payment
     *
     * @throws InvalidArgumentException If invoice cannot receive payments or amount is invalid
     */
    public function applyPayment(Invoice $invoice, Payment $payment, string $amount): InvoicePayment
    {
        // Validate invoice can receive payment
        if (! $invoice->canReceivePayment()) {
            throw new InvalidArgumentException(
                "Cannot apply payment: invoice status '{$invoice->status->label()}' does not accept payments."
            );
        }

        // Validate amount is positive
        if (bccomp($amount, '0', 2) <= 0) {
            throw new InvalidArgumentException(
                'Cannot apply payment: amount must be greater than zero.'
            );
        }

        // Validate amount doesn't exceed outstanding
        $outstanding = $this->getOutstandingAmount($invoice);
        if (bccomp($amount, $outstanding, 2) > 0) {
            throw new InvalidArgumentException(
                "Cannot apply payment: amount ({$amount}) exceeds outstanding balance ({$outstanding})."
            );
        }

        // Validate currencies match
        if ($invoice->currency !== $payment->currency) {
            throw new InvalidArgumentException(
                "Cannot apply payment: currency mismatch. Invoice: {$invoice->currency}, Payment: {$payment->currency}."
            );
        }

        return DB::transaction(function () use ($invoice, $payment, $amount): InvoicePayment {
            // Create the invoice payment record
            $invoicePayment = InvoicePayment::create([
                'invoice_id' => $invoice->id,
                'payment_id' => $payment->id,
                'amount_applied' => $amount,
                'applied_at' => now(),
                'applied_by' => Auth::id(),
            ]);

            // Update invoice amount_paid
            $invoice->amount_paid = bcadd($invoice->amount_paid, $amount, 2);
            $invoice->save();

            // Update status based on payment
            $this->updateStatusAfterPayment($invoice);

            // Log the payment application
            $this->logInvoiceEvent(
                $invoice,
                'payment_applied',
                [
                    'amount_paid' => bcsub($invoice->amount_paid, $amount, 2),
                ],
                [
                    'amount_paid' => $invoice->amount_paid,
                    'payment_id' => $payment->id,
                    'amount_applied' => $amount,
                ]
            );

            return $invoicePayment;
        });
    }

    /**
     * Mark an invoice as paid.
     *
     * Verifies that amount_paid >= total_amount and transitions to paid status.
     *
     * @throws InvalidArgumentException If invoice is not fully paid
     */
    public function markPaid(Invoice $invoice): Invoice
    {
        if (bccomp($invoice->amount_paid, $invoice->total_amount, 2) < 0) {
            $outstanding = $this->getOutstandingAmount($invoice);
            throw new InvalidArgumentException(
                "Cannot mark invoice as paid: outstanding balance of {$outstanding} remains."
            );
        }

        if ($invoice->status === InvoiceStatus::Paid) {
            return $invoice;
        }

        if (! $invoice->status->canTransitionTo(InvoiceStatus::Paid)) {
            throw new InvalidArgumentException(
                "Cannot mark invoice as paid: invalid transition from {$invoice->status->label()} to Paid."
            );
        }

        $oldStatus = $invoice->status;
        $invoice->status = InvoiceStatus::Paid;
        $invoice->save();

        $this->logInvoiceEvent(
            $invoice,
            AuditLog::EVENT_STATUS_CHANGE,
            ['status' => $oldStatus->value],
            ['status' => InvoiceStatus::Paid->value]
        );

        // TODO: Emit InvoicePaid event for downstream modules
        // event(new InvoicePaid($invoice));

        return $invoice;
    }

    /**
     * Cancel a draft invoice.
     *
     * Only draft invoices can be cancelled.
     *
     * @throws InvalidArgumentException If invoice is not in draft status
     */
    public function cancel(Invoice $invoice): Invoice
    {
        if (! $invoice->canBeCancelled()) {
            throw new InvalidArgumentException(
                "Cannot cancel invoice: only draft invoices can be cancelled. Current status: {$invoice->status->label()}"
            );
        }

        $oldStatus = $invoice->status;
        $invoice->status = InvoiceStatus::Cancelled;
        $invoice->save();

        $this->logInvoiceEvent(
            $invoice,
            AuditLog::EVENT_STATUS_CHANGE,
            ['status' => $oldStatus->value],
            ['status' => InvoiceStatus::Cancelled->value]
        );

        return $invoice;
    }

    /**
     * Get the outstanding amount on an invoice.
     *
     * Returns total_amount - amount_paid.
     */
    public function getOutstandingAmount(Invoice $invoice): string
    {
        return bcsub($invoice->total_amount, $invoice->amount_paid, 2);
    }

    /**
     * Find an invoice by source reference.
     *
     * Used for idempotency to prevent duplicate invoices for the same event.
     */
    public function findBySource(string $sourceType, int $sourceId): ?Invoice
    {
        return Invoice::where('source_type', $sourceType)
            ->where('source_id', $sourceId)
            ->first();
    }

    /**
     * Add lines to a draft invoice and recalculate totals.
     *
     * @param  array<int, array{description: string, quantity: string|float, unit_price: string|float, tax_rate?: string|float, tax_amount?: string|float, sellable_sku_id?: int|null, metadata?: array<string, mixed>}>  $lines
     *
     * @throws InvalidArgumentException If invoice is not a draft
     */
    public function addLines(Invoice $invoice, array $lines): Invoice
    {
        if (! $invoice->isDraft()) {
            throw new InvalidArgumentException(
                'Cannot add lines: invoice is not in draft status.'
            );
        }

        DB::transaction(function () use ($invoice, $lines): void {
            foreach ($lines as $lineData) {
                $line = new InvoiceLine([
                    'invoice_id' => $invoice->id,
                    'description' => $lineData['description'],
                    'quantity' => (string) $lineData['quantity'],
                    'unit_price' => (string) $lineData['unit_price'],
                    'tax_rate' => (string) ($lineData['tax_rate'] ?? '0'),
                    'sellable_sku_id' => $lineData['sellable_sku_id'] ?? null,
                    'metadata' => $lineData['metadata'] ?? null,
                ]);

                // Calculate tax if not provided
                if (isset($lineData['tax_amount'])) {
                    $line->tax_amount = (string) $lineData['tax_amount'];
                } else {
                    $line->tax_amount = $line->calculateTaxAmount();
                }

                $line->save();
            }

            // Recalculate invoice totals
            $this->recalculateTotals($invoice);
        });

        return $invoice->fresh();
    }

    /**
     * Recalculate invoice totals from lines.
     */
    public function recalculateTotals(Invoice $invoice): Invoice
    {
        $lines = $invoice->invoiceLines()->get();

        $subtotal = '0.00';
        $taxAmount = '0.00';

        foreach ($lines as $line) {
            $lineSubtotal = bcmul($line->quantity, $line->unit_price, 2);
            $subtotal = bcadd($subtotal, $lineSubtotal, 2);
            $taxAmount = bcadd($taxAmount, $line->tax_amount, 2);
        }

        $totalAmount = bcadd($subtotal, $taxAmount, 2);

        $invoice->subtotal = $subtotal;
        $invoice->tax_amount = $taxAmount;
        $invoice->total_amount = $totalAmount;
        $invoice->save();

        return $invoice;
    }

    /**
     * Generate a sequential invoice number.
     *
     * Format: INV-YYYY-NNNNNN (e.g., INV-2026-000001)
     */
    protected function generateInvoiceNumber(): string
    {
        $year = now()->year;
        $prefix = "INV-{$year}-";

        // Get the last invoice number for this year
        $lastInvoice = Invoice::where('invoice_number', 'like', $prefix.'%')
            ->orderByRaw('CAST(SUBSTRING(invoice_number, -6) AS UNSIGNED) DESC')
            ->first();

        if ($lastInvoice !== null && $lastInvoice->invoice_number !== null) {
            $lastNumber = (int) substr($lastInvoice->invoice_number, -6);
            $nextNumber = $lastNumber + 1;
        } else {
            $nextNumber = 1;
        }

        return $prefix.str_pad((string) $nextNumber, 6, '0', STR_PAD_LEFT);
    }

    /**
     * Validate source reference requirements based on invoice type.
     *
     * @throws InvalidArgumentException If source reference requirements are not met
     */
    protected function validateSourceReference(InvoiceType $invoiceType, ?string $sourceType, ?int $sourceId): void
    {
        // Check if source reference is required
        if ($invoiceType->requiresSourceReference()) {
            if ($sourceType === null || $sourceId === null) {
                throw new InvalidArgumentException(
                    "Cannot create {$invoiceType->label()} invoice: source reference is required. ".
                    "Expected source_type: '{$invoiceType->expectedSourceType()}'."
                );
            }

            // Validate source type matches expected
            $expectedSourceType = $invoiceType->expectedSourceType();
            if ($sourceType !== $expectedSourceType) {
                throw new InvalidArgumentException(
                    "Cannot create {$invoiceType->label()} invoice: invalid source type. ".
                    "Expected: '{$expectedSourceType}', got: '{$sourceType}'."
                );
            }
        }
    }

    /**
     * Update invoice status after payment is applied.
     */
    protected function updateStatusAfterPayment(Invoice $invoice): void
    {
        $outstanding = $this->getOutstandingAmount($invoice);

        if (bccomp($outstanding, '0', 2) <= 0) {
            // Fully paid
            if ($invoice->status !== InvoiceStatus::Paid) {
                $oldStatus = $invoice->status;
                $invoice->status = InvoiceStatus::Paid;
                $invoice->save();

                $this->logInvoiceEvent(
                    $invoice,
                    AuditLog::EVENT_STATUS_CHANGE,
                    ['status' => $oldStatus->value],
                    ['status' => InvoiceStatus::Paid->value]
                );

                // TODO: Emit InvoicePaid event
                // event(new InvoicePaid($invoice));
            }
        } elseif (bccomp($invoice->amount_paid, '0', 2) > 0 && $invoice->status === InvoiceStatus::Issued) {
            // Partially paid
            $oldStatus = $invoice->status;
            $invoice->status = InvoiceStatus::PartiallyPaid;
            $invoice->save();

            $this->logInvoiceEvent(
                $invoice,
                AuditLog::EVENT_STATUS_CHANGE,
                ['status' => $oldStatus->value],
                ['status' => InvoiceStatus::PartiallyPaid->value]
            );
        }
    }

    /**
     * Log an invoice event to the audit log.
     *
     * @param  array<string, mixed>  $oldValues
     * @param  array<string, mixed>  $newValues
     */
    protected function logInvoiceEvent(
        Invoice $invoice,
        string $event,
        array $oldValues,
        array $newValues
    ): void {
        $invoice->auditLogs()->create([
            'event' => $event,
            'old_values' => $oldValues,
            'new_values' => $newValues,
            'user_id' => Auth::id(),
        ]);
    }

    /**
     * Get the FX rate for a given currency to EUR (base currency).
     *
     * Returns the rate to convert 1 unit of the currency to EUR.
     * For example, if 1 GBP = 1.17 EUR, this returns '1.170000'.
     *
     * Note: This is a stub implementation. In production, this should
     * integrate with an external FX rate provider (e.g., ECB, XE, etc.).
     *
     * @param  string  $currency  The currency code (e.g., 'GBP', 'USD')
     * @return string The FX rate as a decimal string with 6 decimal places
     */
    protected function getFxRateForCurrency(string $currency): string
    {
        // TODO: In production, integrate with an FX rate provider
        // This stub provides approximate rates for development/testing
        // These rates should be fetched from a reliable source in production

        $stubRates = [
            'GBP' => '1.170000',  // 1 GBP ≈ 1.17 EUR
            'USD' => '0.920000',  // 1 USD ≈ 0.92 EUR
            'CHF' => '1.040000',  // 1 CHF ≈ 1.04 EUR
            'JPY' => '0.006100',  // 1 JPY ≈ 0.0061 EUR
        ];

        return $stubRates[$currency] ?? '1.000000';
    }

    /**
     * Validate that the currency is supported.
     *
     * @throws InvalidArgumentException If currency is not supported
     */
    public function validateCurrency(string $currency): void
    {
        $supportedCurrencies = array_keys(Invoice::getSupportedCurrencies());

        if (! in_array($currency, $supportedCurrencies, true)) {
            throw new InvalidArgumentException(
                "Currency '{$currency}' is not supported. Supported currencies: ".implode(', ', $supportedCurrencies)
            );
        }
    }
}
