<?php

namespace App\Services\Finance;

use App\Enums\Finance\InvoiceStatus;
use App\Enums\Finance\InvoiceType;
use App\Enums\Finance\OverpaymentHandling;
use App\Events\Finance\InvoicePaid;
use App\Models\AuditLog;
use App\Models\Customer\Customer;
use App\Models\Finance\CustomerCredit;
use App\Models\Finance\Invoice;
use App\Models\Finance\InvoiceLine;
use App\Models\Finance\InvoicePayment;
use App\Models\Finance\Payment;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use InvalidArgumentException;

/**
 * Service for managing Invoice lifecycle and operations.
 *
 * Centralizes all invoice business logic including creation, issuance,
 * payment application, and status management.
 *
 * Finance is consequence, not cause - invoices are generated by other modules
 * but managed through this service.
 */
class InvoiceService
{
    /**
     * Create a draft invoice.
     *
     * Creates a new invoice in draft status that can be edited until issued.
     * Invoice type is locked at creation and cannot be changed.
     *
     * @param  InvoiceType  $invoiceType  The type of invoice (INV0-INV4)
     * @param  Customer  $customer  The customer for this invoice
     * @param  array<int, array{description: string, quantity: string|float, unit_price: string|float, tax_rate?: string|float, tax_amount?: string|float, sellable_sku_id?: int|null, metadata?: array<string, mixed>}>  $lines  Invoice lines
     * @param  string|null  $sourceType  The type of source entity (subscription, voucher_sale, etc.)
     * @param  string|int|null  $sourceId  The ID of the source entity (supports UUID or integer)
     * @param  string  $currency  Currency code (default: EUR)
     * @param  Carbon|null  $dueDate  Optional due date
     * @param  string|null  $notes  Optional notes
     *
     * @throws InvalidArgumentException If validation fails or duplicate source exists
     */
    public function createDraft(
        InvoiceType $invoiceType,
        Customer $customer,
        array $lines,
        ?string $sourceType = null,
        string|int|null $sourceId = null,
        string $currency = 'EUR',
        ?Carbon $dueDate = null,
        ?string $notes = null
    ): Invoice {
        // Validate source reference requirements
        $this->validateSourceReference($invoiceType, $sourceType, $sourceId);

        // Validate currency is supported
        $this->validateCurrency($currency);

        // Check for duplicate invoice for same source (idempotency)
        if ($sourceType !== null && $sourceId !== null) {
            $existing = $this->findBySource($sourceType, $sourceId);
            if ($existing !== null) {
                return $existing;
            }
        }

        return DB::transaction(function () use ($invoiceType, $customer, $lines, $sourceType, $sourceId, $currency, $dueDate, $notes): Invoice {
            // Create the invoice
            $invoice = Invoice::create([
                'invoice_type' => $invoiceType,
                'customer_id' => $customer->id,
                'currency' => $currency,
                'status' => InvoiceStatus::Draft,
                'source_type' => $sourceType,
                'source_id' => $sourceId,
                'due_date' => $dueDate,
                'notes' => $notes,
                'subtotal' => '0.00',
                'tax_amount' => '0.00',
                'total_amount' => '0.00',
                'amount_paid' => '0.00',
            ]);

            // Add lines and calculate totals
            $this->addLines($invoice, $lines);

            // Log creation
            $this->logInvoiceEvent(
                $invoice,
                AuditLog::EVENT_CREATED,
                [],
                [
                    'invoice_type' => $invoiceType->value,
                    'customer_id' => $customer->id,
                    'source_type' => $sourceType,
                    'source_id' => $sourceId,
                    'total_amount' => $invoice->total_amount,
                ]
            );

            return $invoice->fresh();
        });
    }

    /**
     * Issue a draft invoice.
     *
     * Transitions draft to issued, generates sequential invoice_number,
     * sets issued_at, and makes lines immutable.
     *
     * @throws InvalidArgumentException If invoice is not in draft status or validation fails
     */
    public function issue(Invoice $invoice): Invoice
    {
        if (! $invoice->isDraft()) {
            throw new InvalidArgumentException(
                "Cannot issue invoice: invoice is not in draft status. Current status: {$invoice->status->label()}"
            );
        }

        // Validate invoice has at least one line
        if ($invoice->invoiceLines()->count() === 0) {
            throw new InvalidArgumentException(
                'Cannot issue invoice: invoice must have at least one line item.'
            );
        }

        // Validate total amount is positive
        if (bccomp($invoice->total_amount, '0', 2) <= 0) {
            throw new InvalidArgumentException(
                'Cannot issue invoice: total amount must be greater than zero.'
            );
        }

        // Validate due date requirements
        if ($invoice->invoice_type->requiresDueDate() && $invoice->due_date === null) {
            throw new InvalidArgumentException(
                "Cannot issue invoice: due date is required for {$invoice->invoice_type->label()} invoices."
            );
        }

        return DB::transaction(function () use ($invoice): Invoice {
            $oldStatus = $invoice->status;

            // Generate invoice number
            $invoiceNumber = $this->generateInvoiceNumber();

            // Update invoice
            $invoice->invoice_number = $invoiceNumber;
            $invoice->status = InvoiceStatus::Issued;
            $invoice->issued_at = now();

            // Capture FX rate at issuance for non-EUR currencies
            if ($invoice->currency !== 'EUR') {
                $invoice->fx_rate_at_issuance = $this->getFxRateForCurrency($invoice->currency);
            }

            // Set default due date if not set and applicable
            if ($invoice->due_date === null) {
                $defaultDays = $invoice->invoice_type->defaultDueDateDays();
                if ($defaultDays !== null) {
                    $invoice->due_date = now()->addDays($defaultDays);
                }
            }

            $invoice->save();

            // Log the issuance
            $this->logInvoiceEvent(
                $invoice,
                AuditLog::EVENT_STATUS_CHANGE,
                [
                    'status' => $oldStatus->value,
                    'invoice_number' => null,
                    'issued_at' => null,
                ],
                [
                    'status' => InvoiceStatus::Issued->value,
                    'invoice_number' => $invoiceNumber,
                    'issued_at' => $invoice->issued_at->toIso8601String(),
                    'due_date' => $invoice->due_date?->toDateString(),
                ]
            );

            // Trigger Xero sync (US-E098)
            $this->triggerXeroSync($invoice);

            return $invoice;
        });
    }

    /**
     * Apply a payment to an invoice.
     *
     * Creates an InvoicePayment record linking the payment to the invoice.
     * Updates invoice amount_paid and status accordingly.
     *
     * @param  string  $amount  The amount to apply from the payment
     *
     * @throws InvalidArgumentException If invoice cannot receive payments or amount is invalid
     */
    public function applyPayment(Invoice $invoice, Payment $payment, string $amount): InvoicePayment
    {
        // Validate invoice can receive payment
        if (! $invoice->canReceivePayment()) {
            throw new InvalidArgumentException(
                "Cannot apply payment: invoice status '{$invoice->status->label()}' does not accept payments."
            );
        }

        // Validate amount is positive
        if (bccomp($amount, '0', 2) <= 0) {
            throw new InvalidArgumentException(
                'Cannot apply payment: amount must be greater than zero.'
            );
        }

        // Validate amount doesn't exceed outstanding
        $outstanding = $this->getOutstandingAmount($invoice);
        if (bccomp($amount, $outstanding, 2) > 0) {
            throw new InvalidArgumentException(
                "Cannot apply payment: amount ({$amount}) exceeds outstanding balance ({$outstanding})."
            );
        }

        // Validate currencies match
        if ($invoice->currency !== $payment->currency) {
            throw new InvalidArgumentException(
                "Cannot apply payment: currency mismatch. Invoice: {$invoice->currency}, Payment: {$payment->currency}."
            );
        }

        return DB::transaction(function () use ($invoice, $payment, $amount): InvoicePayment {
            // Create the invoice payment record
            $invoicePayment = InvoicePayment::create([
                'invoice_id' => $invoice->id,
                'payment_id' => $payment->id,
                'amount_applied' => $amount,
                'applied_at' => now(),
                'applied_by' => Auth::id(),
            ]);

            // Update invoice amount_paid
            $invoice->amount_paid = bcadd($invoice->amount_paid, $amount, 2);
            $invoice->save();

            // Update status based on payment
            $this->updateStatusAfterPayment($invoice);

            // Log the payment application
            $this->logInvoiceEvent(
                $invoice,
                'payment_applied',
                [
                    'amount_paid' => bcsub($invoice->amount_paid, $amount, 2),
                ],
                [
                    'amount_paid' => $invoice->amount_paid,
                    'payment_id' => $payment->id,
                    'amount_applied' => $amount,
                ]
            );

            return $invoicePayment;
        });
    }

    /**
     * Apply a payment to an invoice with overpayment handling.
     *
     * When payment amount exceeds the invoice outstanding, this method handles
     * the overpayment according to the specified handling option:
     *
     * - ApplyPartial: Only apply the outstanding amount, leave remainder on payment
     * - CreateCredit: Apply full amount and create customer credit for the excess
     *
     * @param  string  $amount  The amount to apply from the payment
     * @param  OverpaymentHandling  $overpaymentHandling  How to handle overpayment
     * @return array{invoice_payment: InvoicePayment, customer_credit: CustomerCredit|null, amount_applied: string, credit_amount: string}
     *
     * @throws InvalidArgumentException If invoice cannot receive payments or amount is invalid
     */
    public function applyPaymentWithOverpaymentHandling(
        Invoice $invoice,
        Payment $payment,
        string $amount,
        OverpaymentHandling $overpaymentHandling = OverpaymentHandling::ApplyPartial
    ): array {
        // Validate invoice can receive payment
        if (! $invoice->canReceivePayment()) {
            throw new InvalidArgumentException(
                "Cannot apply payment: invoice status '{$invoice->status->label()}' does not accept payments."
            );
        }

        // Validate amount is positive
        if (bccomp($amount, '0', 2) <= 0) {
            throw new InvalidArgumentException(
                'Cannot apply payment: amount must be greater than zero.'
            );
        }

        // Validate currencies match
        if ($invoice->currency !== $payment->currency) {
            throw new InvalidArgumentException(
                "Cannot apply payment: currency mismatch. Invoice: {$invoice->currency}, Payment: {$payment->currency}."
            );
        }

        $outstanding = $this->getOutstandingAmount($invoice);
        $isOverpayment = bccomp($amount, $outstanding, 2) > 0;

        // If not an overpayment, use regular applyPayment
        if (! $isOverpayment) {
            $invoicePayment = $this->applyPayment($invoice, $payment, $amount);

            return [
                'invoice_payment' => $invoicePayment,
                'customer_credit' => null,
                'amount_applied' => $amount,
                'credit_amount' => '0.00',
            ];
        }

        // Handle overpayment according to specified option
        return match ($overpaymentHandling) {
            OverpaymentHandling::ApplyPartial => $this->handleOverpaymentPartial($invoice, $payment, $outstanding),
            OverpaymentHandling::CreateCredit => $this->handleOverpaymentCreateCredit($invoice, $payment, $amount, $outstanding),
        };
    }

    /**
     * Handle overpayment by applying only the outstanding amount.
     *
     * The remaining payment amount stays unapplied and can be used for other invoices.
     *
     * @return array{invoice_payment: InvoicePayment, customer_credit: null, amount_applied: string, credit_amount: string}
     */
    protected function handleOverpaymentPartial(
        Invoice $invoice,
        Payment $payment,
        string $outstanding
    ): array {
        $invoicePayment = $this->applyPayment($invoice, $payment, $outstanding);

        return [
            'invoice_payment' => $invoicePayment,
            'customer_credit' => null,
            'amount_applied' => $outstanding,
            'credit_amount' => '0.00',
        ];
    }

    /**
     * Handle overpayment by creating customer credit for the excess.
     *
     * The full payment amount is applied to the invoice (up to outstanding),
     * and the excess is converted to a customer credit.
     *
     * @return array{invoice_payment: InvoicePayment, customer_credit: CustomerCredit, amount_applied: string, credit_amount: string}
     */
    protected function handleOverpaymentCreateCredit(
        Invoice $invoice,
        Payment $payment,
        string $requestedAmount,
        string $outstanding
    ): array {
        $creditAmount = bcsub($requestedAmount, $outstanding, 2);

        return DB::transaction(function () use ($invoice, $payment, $outstanding, $creditAmount): array {
            // Apply the outstanding amount to the invoice
            $invoicePayment = $this->applyPayment($invoice, $payment, $outstanding);

            // Create customer credit for the excess
            $customer = $invoice->customer;
            $customerCredit = CustomerCredit::createFromOverpayment(
                customer: $customer,
                payment: $payment,
                invoice: $invoice,
                amount: $creditAmount,
                createdBy: Auth::id()
            );

            // Log the credit creation
            $this->logInvoiceEvent(
                $invoice,
                'overpayment_credit_created',
                [],
                [
                    'payment_id' => $payment->id,
                    'credit_id' => $customerCredit->id,
                    'credit_amount' => $creditAmount,
                    'reason' => 'Overpayment on invoice',
                ]
            );

            Log::channel('finance')->info('Customer credit created from overpayment', [
                'invoice_id' => $invoice->id,
                'invoice_number' => $invoice->invoice_number,
                'payment_id' => $payment->id,
                'payment_reference' => $payment->payment_reference,
                'customer_id' => $customer->id,
                'credit_id' => $customerCredit->id,
                'credit_amount' => $creditAmount,
                'currency' => $payment->currency,
            ]);

            return [
                'invoice_payment' => $invoicePayment,
                'customer_credit' => $customerCredit,
                'amount_applied' => $outstanding,
                'credit_amount' => $creditAmount,
            ];
        });
    }

    /**
     * Check if a payment amount would be an overpayment for an invoice.
     *
     * @param  string  $amount  The payment amount to check
     */
    public function isOverpayment(Invoice $invoice, string $amount): bool
    {
        $outstanding = $this->getOutstandingAmount($invoice);

        return bccomp($amount, $outstanding, 2) > 0;
    }

    /**
     * Calculate the overpayment amount (excess over outstanding).
     *
     * @param  string  $amount  The payment amount
     * @return string The excess amount (0.00 if not an overpayment)
     */
    public function calculateOverpaymentAmount(Invoice $invoice, string $amount): string
    {
        $outstanding = $this->getOutstandingAmount($invoice);

        if (bccomp($amount, $outstanding, 2) <= 0) {
            return '0.00';
        }

        return bcsub($amount, $outstanding, 2);
    }

    /**
     * Mark an invoice as paid.
     *
     * Verifies that amount_paid >= total_amount and transitions to paid status.
     *
     * @throws InvalidArgumentException If invoice is not fully paid
     */
    public function markPaid(Invoice $invoice): Invoice
    {
        if (bccomp($invoice->amount_paid, $invoice->total_amount, 2) < 0) {
            $outstanding = $this->getOutstandingAmount($invoice);
            throw new InvalidArgumentException(
                "Cannot mark invoice as paid: outstanding balance of {$outstanding} remains."
            );
        }

        if ($invoice->status === InvoiceStatus::Paid) {
            return $invoice;
        }

        if (! $invoice->status->canTransitionTo(InvoiceStatus::Paid)) {
            throw new InvalidArgumentException(
                "Cannot mark invoice as paid: invalid transition from {$invoice->status->label()} to Paid."
            );
        }

        $oldStatus = $invoice->status;
        $invoice->status = InvoiceStatus::Paid;
        $invoice->save();

        $this->logInvoiceEvent(
            $invoice,
            AuditLog::EVENT_STATUS_CHANGE,
            ['status' => $oldStatus->value],
            ['status' => InvoiceStatus::Paid->value]
        );

        // Emit InvoicePaid event for downstream modules
        $this->emitInvoicePaidEvent($invoice);

        return $invoice;
    }

    /**
     * Cancel a draft invoice.
     *
     * Only draft invoices can be cancelled.
     *
     * @throws InvalidArgumentException If invoice is not in draft status
     */
    public function cancel(Invoice $invoice): Invoice
    {
        if (! $invoice->canBeCancelled()) {
            throw new InvalidArgumentException(
                "Cannot cancel invoice: only draft invoices can be cancelled. Current status: {$invoice->status->label()}"
            );
        }

        $oldStatus = $invoice->status;
        $invoice->status = InvoiceStatus::Cancelled;
        $invoice->save();

        $this->logInvoiceEvent(
            $invoice,
            AuditLog::EVENT_STATUS_CHANGE,
            ['status' => $oldStatus->value],
            ['status' => InvoiceStatus::Cancelled->value]
        );

        return $invoice;
    }

    /**
     * Get the outstanding amount on an invoice.
     *
     * Returns total_amount - amount_paid.
     */
    public function getOutstandingAmount(Invoice $invoice): string
    {
        return bcsub($invoice->total_amount, $invoice->amount_paid, 2);
    }

    /**
     * Find an invoice by source reference.
     *
     * Used for idempotency to prevent duplicate invoices for the same event.
     *
     * @param  string|int  $sourceId  The ID of the source entity (supports UUID or integer)
     */
    public function findBySource(string $sourceType, string|int $sourceId): ?Invoice
    {
        return Invoice::where('source_type', $sourceType)
            ->where('source_id', $sourceId)
            ->first();
    }

    /**
     * Add lines to a draft invoice and recalculate totals.
     *
     * @param  array<int, array{description: string, quantity: string|float, unit_price: string|float, tax_rate?: string|float, tax_amount?: string|float, sellable_sku_id?: int|null, metadata?: array<string, mixed>}>  $lines
     *
     * @throws InvalidArgumentException If invoice is not a draft or lines violate invoice type restrictions
     */
    public function addLines(Invoice $invoice, array $lines): Invoice
    {
        if (! $invoice->isDraft()) {
            throw new InvalidArgumentException(
                'Cannot add lines: invoice is not in draft status.'
            );
        }

        // Pre-validate INV4 restrictions before processing any lines
        $this->validateLinesForInvoiceType($invoice, $lines);

        DB::transaction(function () use ($invoice, $lines): void {
            foreach ($lines as $lineData) {
                $line = new InvoiceLine([
                    'invoice_id' => $invoice->id,
                    'description' => $lineData['description'],
                    'quantity' => (string) $lineData['quantity'],
                    'unit_price' => (string) $lineData['unit_price'],
                    'tax_rate' => (string) ($lineData['tax_rate'] ?? '0'),
                    'sellable_sku_id' => $lineData['sellable_sku_id'] ?? null,
                    'metadata' => $lineData['metadata'] ?? null,
                ]);

                // Calculate tax if not provided
                if (isset($lineData['tax_amount'])) {
                    $line->tax_amount = (string) $lineData['tax_amount'];
                } else {
                    $line->tax_amount = $line->calculateTaxAmount();
                }

                $line->save();
            }

            // Recalculate invoice totals
            $this->recalculateTotals($invoice);
        });

        return $invoice->fresh();
    }

    /**
     * Validate lines for invoice type restrictions.
     *
     * INV4 (Service Events) invoices cannot include wine/inventory products.
     * Only service fees (attendance, tasting, consultation, etc.) are allowed.
     *
     * @param  array<int, array{description: string, quantity: string|float, unit_price: string|float, tax_rate?: string|float, tax_amount?: string|float, sellable_sku_id?: int|null, metadata?: array<string, mixed>}>  $lines
     *
     * @throws InvalidArgumentException If lines violate invoice type restrictions
     */
    protected function validateLinesForInvoiceType(Invoice $invoice, array $lines): void
    {
        // INV4 restriction: no wine/inventory products (sellable_sku_id)
        if ($invoice->invoice_type === InvoiceType::ServiceEvents) {
            $linesWithProducts = [];
            foreach ($lines as $index => $lineData) {
                $sellableSkuId = $lineData['sellable_sku_id'] ?? null;
                if ($sellableSkuId !== null) {
                    $linesWithProducts[] = $lineData['description'];
                }
            }

            if (! empty($linesWithProducts)) {
                throw new InvalidArgumentException(
                    'INV4 (Service Events) invoices cannot include wine/inventory products. '.
                    'The following lines have product references: '.implode(', ', $linesWithProducts).'. '.
                    'Service event invoices are for attendance fees, service fees, and handling only. '.
                    'Wine/inventory costs should be billed via INV1 (Voucher Sale) invoices.'
                );
            }
        }
    }

    /**
     * Recalculate invoice totals from lines.
     */
    public function recalculateTotals(Invoice $invoice): Invoice
    {
        $lines = $invoice->invoiceLines()->get();

        $subtotal = '0.00';
        $taxAmount = '0.00';

        foreach ($lines as $line) {
            $lineSubtotal = bcmul($line->quantity, $line->unit_price, 2);
            $subtotal = bcadd($subtotal, $lineSubtotal, 2);
            $taxAmount = bcadd($taxAmount, $line->tax_amount, 2);
        }

        $totalAmount = bcadd($subtotal, $taxAmount, 2);

        $invoice->subtotal = $subtotal;
        $invoice->tax_amount = $taxAmount;
        $invoice->total_amount = $totalAmount;
        $invoice->save();

        return $invoice;
    }

    /**
     * Generate a sequential invoice number.
     *
     * Format: INV-YYYY-NNNNNN (e.g., INV-2026-000001)
     */
    protected function generateInvoiceNumber(): string
    {
        $year = now()->year;
        $prefix = "INV-{$year}-";

        // Get the last invoice number for this year
        $lastInvoice = Invoice::where('invoice_number', 'like', $prefix.'%')
            ->orderByRaw('CAST(SUBSTRING(invoice_number, -6) AS UNSIGNED) DESC')
            ->first();

        if ($lastInvoice !== null && $lastInvoice->invoice_number !== null) {
            $lastNumber = (int) substr($lastInvoice->invoice_number, -6);
            $nextNumber = $lastNumber + 1;
        } else {
            $nextNumber = 1;
        }

        return $prefix.str_pad((string) $nextNumber, 6, '0', STR_PAD_LEFT);
    }

    /**
     * Validate source reference requirements based on invoice type.
     *
     * @param  string|int|null  $sourceId  The ID of the source entity (supports UUID or integer)
     *
     * @throws InvalidArgumentException If source reference requirements are not met
     */
    protected function validateSourceReference(InvoiceType $invoiceType, ?string $sourceType, string|int|null $sourceId): void
    {
        // Check if source reference is required
        if ($invoiceType->requiresSourceReference()) {
            if ($sourceType === null || $sourceId === null) {
                throw new InvalidArgumentException(
                    "Cannot create {$invoiceType->label()} invoice: source reference is required. ".
                    "Expected source_type: '{$invoiceType->expectedSourceType()}'."
                );
            }

            // Validate source type matches expected
            $expectedSourceType = $invoiceType->expectedSourceType();
            if ($sourceType !== $expectedSourceType) {
                throw new InvalidArgumentException(
                    "Cannot create {$invoiceType->label()} invoice: invalid source type. ".
                    "Expected: '{$expectedSourceType}', got: '{$sourceType}'."
                );
            }
        }
    }

    /**
     * Update invoice status after payment is applied.
     */
    protected function updateStatusAfterPayment(Invoice $invoice): void
    {
        $outstanding = $this->getOutstandingAmount($invoice);

        if (bccomp($outstanding, '0', 2) <= 0) {
            // Fully paid
            if ($invoice->status !== InvoiceStatus::Paid) {
                $oldStatus = $invoice->status;
                $invoice->status = InvoiceStatus::Paid;
                $invoice->save();

                $this->logInvoiceEvent(
                    $invoice,
                    AuditLog::EVENT_STATUS_CHANGE,
                    ['status' => $oldStatus->value],
                    ['status' => InvoiceStatus::Paid->value]
                );

                // Emit InvoicePaid event for downstream modules
                $this->emitInvoicePaidEvent($invoice);
            }
        } elseif (bccomp($invoice->amount_paid, '0', 2) > 0 && $invoice->status === InvoiceStatus::Issued) {
            // Partially paid
            $oldStatus = $invoice->status;
            $invoice->status = InvoiceStatus::PartiallyPaid;
            $invoice->save();

            $this->logInvoiceEvent(
                $invoice,
                AuditLog::EVENT_STATUS_CHANGE,
                ['status' => $oldStatus->value],
                ['status' => InvoiceStatus::PartiallyPaid->value]
            );
        }
    }

    /**
     * Log an invoice event to the audit log.
     *
     * @param  array<string, mixed>  $oldValues
     * @param  array<string, mixed>  $newValues
     */
    protected function logInvoiceEvent(
        Invoice $invoice,
        string $event,
        array $oldValues,
        array $newValues
    ): void {
        $invoice->auditLogs()->create([
            'event' => $event,
            'old_values' => $oldValues,
            'new_values' => $newValues,
            'user_id' => Auth::id(),
        ]);
    }

    /**
     * Get the FX rate for a given currency to EUR (base currency).
     *
     * Returns the rate to convert 1 unit of the currency to EUR.
     * For example, if 1 GBP = 1.17 EUR, this returns '1.170000'.
     *
     * Note: This is a stub implementation. In production, this should
     * integrate with an external FX rate provider (e.g., ECB, XE, etc.).
     *
     * @param  string  $currency  The currency code (e.g., 'GBP', 'USD')
     * @return string The FX rate as a decimal string with 6 decimal places
     */
    protected function getFxRateForCurrency(string $currency): string
    {
        // TODO: In production, integrate with an FX rate provider
        // This stub provides approximate rates for development/testing
        // These rates should be fetched from a reliable source in production

        $stubRates = [
            'GBP' => '1.170000',  // 1 GBP ≈ 1.17 EUR
            'USD' => '0.920000',  // 1 USD ≈ 0.92 EUR
            'CHF' => '1.040000',  // 1 CHF ≈ 1.04 EUR
            'JPY' => '0.006100',  // 1 JPY ≈ 0.0061 EUR
        ];

        return $stubRates[$currency] ?? '1.000000';
    }

    /**
     * Validate that the currency is supported.
     *
     * @throws InvalidArgumentException If currency is not supported
     */
    public function validateCurrency(string $currency): void
    {
        $supportedCurrencies = array_keys(Invoice::getSupportedCurrencies());

        if (! in_array($currency, $supportedCurrencies, true)) {
            throw new InvalidArgumentException(
                "Currency '{$currency}' is not supported. Supported currencies: ".implode(', ', $supportedCurrencies)
            );
        }
    }

    /**
     * Emit InvoicePaid event for downstream modules.
     *
     * This method dispatches the InvoicePaid event which signals to other
     * modules that an invoice has been fully paid. Each invoice type
     * triggers different downstream effects:
     *
     * - INV1 (Voucher Sale): Module A creates/activates vouchers
     * - INV0 (Membership): Module K updates membership status
     * - INV2 (Shipping): Module C confirms shipment execution
     * - INV3 (Storage): Module B unlocks custody operations
     * - INV4 (Service Events): Module handles event confirmation
     *
     * IMPORTANT: Finance is consequence, not cause. This event is evidence
     * of payment, not authority for operational actions.
     */
    protected function emitInvoicePaidEvent(Invoice $invoice): void
    {
        // Generate a correlation ID for tracing across modules
        $correlationId = Str::uuid()->toString();

        // Log the event emission for correlation tracking
        Log::channel('finance')->info('InvoicePaid event emitted', [
            'invoice_id' => $invoice->id,
            'invoice_number' => $invoice->invoice_number,
            'invoice_type' => $invoice->invoice_type->value,
            'customer_id' => $invoice->customer_id,
            'source_type' => $invoice->source_type,
            'source_id' => $invoice->source_id,
            'total_amount' => $invoice->total_amount,
            'amount_paid' => $invoice->amount_paid,
            'currency' => $invoice->currency,
            'correlation_id' => $correlationId,
        ]);

        // Dispatch the event
        event(new InvoicePaid(
            invoice: $invoice,
            totalPaid: $invoice->amount_paid,
            correlationId: $correlationId
        ));

        // Log the correlation in the audit trail
        $this->logInvoiceEvent(
            $invoice,
            'payment_confirmed',
            [],
            [
                'correlation_id' => $correlationId,
                'invoice_type' => $invoice->invoice_type->value,
                'source_type' => $invoice->source_type,
                'source_id' => $invoice->source_id,
                'total_paid' => $invoice->amount_paid,
                'downstream_trigger' => $this->getDownstreamDescription($invoice),
            ]
        );
    }

    /**
     * Get a description of what downstream module should be triggered.
     */
    protected function getDownstreamDescription(Invoice $invoice): string
    {
        return match ($invoice->invoice_type) {
            InvoiceType::VoucherSale => 'Module A: Voucher creation/activation',
            InvoiceType::MembershipService => 'Module K: Membership status update',
            InvoiceType::ShippingRedemption => 'Module C: Shipment confirmation',
            InvoiceType::StorageFee => 'Module B: Custody operations unlock',
            InvoiceType::ServiceEvents => 'Event booking confirmation',
        };
    }

    /**
     * Trigger Xero sync for an issued invoice.
     *
     * This method is called after invoice issuance to sync the invoice to Xero.
     * Errors are logged but do not prevent the invoice from being issued.
     * Failed syncs can be retried via the Xero integration management UI.
     */
    protected function triggerXeroSync(Invoice $invoice): void
    {
        try {
            $xeroService = app(XeroIntegrationService::class);
            $xeroService->syncInvoice($invoice);
        } catch (\Exception $e) {
            // Log the error but don't fail the invoice issuance
            // The sync can be retried later via the Integrations Health page
            Log::channel('finance')->warning('Xero sync failed after invoice issuance', [
                'invoice_id' => $invoice->id,
                'invoice_number' => $invoice->invoice_number,
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Calculate shipping costs for a shipping order.
     *
     * This method takes shipping order data and returns structured invoice lines
     * with separate line items for:
     * - Base shipping fee (carrier costs)
     * - Insurance (if applicable)
     * - Packaging (special handling/materials)
     * - Handling fees (warehouse operations)
     * - Duties (customs duties for cross-border)
     * - Taxes (import taxes for cross-border)
     * - Redemption fee (if applicable - wine redemption from custody)
     *
     * Line types are stored in metadata for reporting and analysis.
     *
     * Shipping-only vs Redemption+Shipping:
     * - Shipping-only: is_redemption = false, no redemption_fee
     * - Redemption: is_redemption = true OR redemption_fee present
     *
     * @param  array{
     *     shipping_order_id: string,
     *     base_shipping_cost?: string,
     *     insurance_cost?: string,
     *     packaging_cost?: string,
     *     handling_cost?: string,
     *     duties_amount?: string,
     *     taxes_amount?: string,
     *     redemption_fee?: array{amount: string, tax_rate: string, description?: string, pricing_snapshot_id?: string},
     *     is_redemption?: bool,
     *     origin_country?: string,
     *     destination_country?: string,
     *     carrier_name?: string,
     *     tracking_number?: string,
     *     tax_rate?: string,
     *     weight_kg?: string,
     *     dimensions?: array{length: string, width: string, height: string},
     *     service_level?: string,
     *     metadata?: array<string, mixed>
     * }  $shippingOrder  The shipping order data from Module C
     * @return array<int, array{
     *     description: string,
     *     quantity: string,
     *     unit_price: string,
     *     tax_rate: string,
     *     sellable_sku_id: int|null,
     *     metadata: array<string, mixed>
     * }>  Invoice lines for the shipping costs
     */
    public function calculateShippingCosts(array $shippingOrder): array
    {
        $lines = [];
        $shippingOrderId = $shippingOrder['shipping_order_id'];
        $defaultTaxRate = $shippingOrder['tax_rate'] ?? '0.00';

        // Build base metadata that will be included in all lines
        $baseMetadata = [
            'shipping_order_id' => $shippingOrderId,
        ];

        // Add cross-border information if present
        $originCountry = $shippingOrder['origin_country'] ?? null;
        $destinationCountry = $shippingOrder['destination_country'] ?? null;
        $isCrossBorder = $originCountry !== null && $destinationCountry !== null && $originCountry !== $destinationCountry;

        if ($isCrossBorder) {
            $baseMetadata['origin_country'] = $originCountry;
            $baseMetadata['destination_country'] = $destinationCountry;
            $baseMetadata['is_cross_border'] = true;
        }

        // Add carrier information
        if (isset($shippingOrder['carrier_name'])) {
            $baseMetadata['carrier_name'] = $shippingOrder['carrier_name'];
        }

        if (isset($shippingOrder['tracking_number'])) {
            $baseMetadata['tracking_number'] = $shippingOrder['tracking_number'];
        }

        // Add shipping details if present
        if (isset($shippingOrder['weight_kg'])) {
            $baseMetadata['weight_kg'] = $shippingOrder['weight_kg'];
        }

        if (isset($shippingOrder['dimensions'])) {
            $baseMetadata['dimensions'] = $shippingOrder['dimensions'];
        }

        if (isset($shippingOrder['service_level'])) {
            $baseMetadata['service_level'] = $shippingOrder['service_level'];
        }

        // Add any custom metadata from the shipping order
        if (isset($shippingOrder['metadata'])) {
            $baseMetadata = array_merge($baseMetadata, $shippingOrder['metadata']);
        }

        // 1. Base Shipping Cost (required)
        if (isset($shippingOrder['base_shipping_cost']) && bccomp($shippingOrder['base_shipping_cost'], '0', 2) > 0) {
            $lines[] = $this->buildShippingLine(
                description: $this->buildShippingDescription($shippingOrder),
                unitPrice: $shippingOrder['base_shipping_cost'],
                taxRate: $defaultTaxRate,
                lineType: 'shipping',
                baseMetadata: $baseMetadata
            );
        }

        // 2. Insurance Cost (optional)
        if (isset($shippingOrder['insurance_cost']) && bccomp($shippingOrder['insurance_cost'], '0', 2) > 0) {
            $lines[] = $this->buildShippingLine(
                description: 'Shipping Insurance',
                unitPrice: $shippingOrder['insurance_cost'],
                taxRate: $defaultTaxRate,
                lineType: 'insurance',
                baseMetadata: $baseMetadata
            );
        }

        // 3. Packaging Cost (optional)
        if (isset($shippingOrder['packaging_cost']) && bccomp($shippingOrder['packaging_cost'], '0', 2) > 0) {
            $lines[] = $this->buildShippingLine(
                description: 'Special Packaging & Materials',
                unitPrice: $shippingOrder['packaging_cost'],
                taxRate: $defaultTaxRate,
                lineType: 'packaging',
                baseMetadata: $baseMetadata
            );
        }

        // 4. Handling Cost (optional - warehouse operations)
        if (isset($shippingOrder['handling_cost']) && bccomp($shippingOrder['handling_cost'], '0', 2) > 0) {
            $lines[] = $this->buildShippingLine(
                description: 'Handling & Warehouse Operations',
                unitPrice: $shippingOrder['handling_cost'],
                taxRate: $defaultTaxRate,
                lineType: 'handling',
                baseMetadata: $baseMetadata
            );
        }

        // 5. Customs Duties (for cross-border shipments)
        if (isset($shippingOrder['duties_amount']) && bccomp($shippingOrder['duties_amount'], '0', 2) > 0) {
            $dutiesDescription = 'Customs Duties';
            if ($isCrossBorder) {
                $dutiesDescription .= " ({$originCountry} → {$destinationCountry})";
            }

            $lines[] = $this->buildShippingLine(
                description: $dutiesDescription,
                unitPrice: $shippingOrder['duties_amount'],
                taxRate: '0.00', // Duties typically don't have VAT applied on top
                lineType: 'duties',
                baseMetadata: $baseMetadata
            );
        }

        // 6. Import Taxes (for cross-border shipments)
        if (isset($shippingOrder['taxes_amount']) && bccomp($shippingOrder['taxes_amount'], '0', 2) > 0) {
            $taxesDescription = 'Import Taxes';
            if ($destinationCountry !== null) {
                $taxesDescription .= " ({$destinationCountry})";
            }

            $lines[] = $this->buildShippingLine(
                description: $taxesDescription,
                unitPrice: $shippingOrder['taxes_amount'],
                taxRate: '0.00', // Import taxes are the tax, don't apply VAT on top
                lineType: 'taxes',
                baseMetadata: $baseMetadata
            );
        }

        // 7. Redemption Fee (if applicable - voucher redemption shipments)
        if (isset($shippingOrder['redemption_fee']) && bccomp($shippingOrder['redemption_fee']['amount'], '0', 2) > 0) {
            $redemptionFee = $shippingOrder['redemption_fee'];
            $redemptionMetadata = array_merge($baseMetadata, [
                'line_type' => 'redemption',
                'shipment_type' => 'redemption',
            ]);

            // Add pricing snapshot ID from Module S if available
            if (isset($redemptionFee['pricing_snapshot_id'])) {
                $redemptionMetadata['pricing_snapshot_id'] = $redemptionFee['pricing_snapshot_id'];
            }

            $lines[] = [
                'description' => $redemptionFee['description'] ?? 'Wine Redemption Fee',
                'quantity' => '1.00',
                'unit_price' => $redemptionFee['amount'],
                'tax_rate' => $redemptionFee['tax_rate'],
                'sellable_sku_id' => null, // Redemption fee is a service
                'metadata' => $redemptionMetadata,
            ];
        }

        return $lines;
    }

    /**
     * Build a single shipping invoice line.
     *
     * @param  array<string, mixed>  $baseMetadata
     * @return array{description: string, quantity: string, unit_price: string, tax_rate: string, sellable_sku_id: int|null, metadata: array<string, mixed>}
     */
    protected function buildShippingLine(
        string $description,
        string $unitPrice,
        string $taxRate,
        string $lineType,
        array $baseMetadata
    ): array {
        $metadata = array_merge($baseMetadata, [
            'line_type' => $lineType,
        ]);

        return [
            'description' => $description,
            'quantity' => '1.00',
            'unit_price' => $unitPrice,
            'tax_rate' => $taxRate,
            'sellable_sku_id' => null, // Shipping lines don't reference sellable SKUs
            'metadata' => $metadata,
        ];
    }

    /**
     * Build description for the base shipping line.
     *
     * @param  array<string, mixed>  $shippingOrder
     */
    protected function buildShippingDescription(array $shippingOrder): string
    {
        $description = 'Shipping';

        // Add service level if present
        if (isset($shippingOrder['service_level'])) {
            $serviceLevel = $shippingOrder['service_level'];
            $description = ucfirst($serviceLevel).' Shipping';
        }

        // Add carrier if present
        if (isset($shippingOrder['carrier_name'])) {
            $description .= ' via '.$shippingOrder['carrier_name'];
        }

        // Add route for cross-border
        $originCountry = $shippingOrder['origin_country'] ?? null;
        $destinationCountry = $shippingOrder['destination_country'] ?? null;
        if ($originCountry !== null && $destinationCountry !== null && $originCountry !== $destinationCountry) {
            $description .= " ({$originCountry} → {$destinationCountry})";
        }

        return $description;
    }

    /**
     * Get the total shipping cost from shipping order data.
     *
     * Returns the sum of all shipping cost components including redemption fee.
     *
     * @param  array{
     *     base_shipping_cost?: string,
     *     insurance_cost?: string,
     *     packaging_cost?: string,
     *     handling_cost?: string,
     *     duties_amount?: string,
     *     taxes_amount?: string,
     *     redemption_fee?: array{amount: string}
     * }  $shippingOrder
     */
    public function getTotalShippingCost(array $shippingOrder): string
    {
        $total = '0.00';

        $costFields = [
            'base_shipping_cost',
            'insurance_cost',
            'packaging_cost',
            'handling_cost',
            'duties_amount',
            'taxes_amount',
        ];

        foreach ($costFields as $field) {
            if (isset($shippingOrder[$field])) {
                $total = bcadd($total, $shippingOrder[$field], 2);
            }
        }

        // Add redemption fee if present
        if (isset($shippingOrder['redemption_fee']['amount'])) {
            $total = bcadd($total, $shippingOrder['redemption_fee']['amount'], 2);
        }

        return $total;
    }

    /**
     * Check if shipping order has duties or taxes (cross-border indicators).
     *
     * @param  array{duties_amount?: string, taxes_amount?: string}  $shippingOrder
     */
    public function hasShippingDutiesOrTaxes(array $shippingOrder): bool
    {
        $hasDuties = isset($shippingOrder['duties_amount']) && bccomp($shippingOrder['duties_amount'], '0', 2) > 0;
        $hasTaxes = isset($shippingOrder['taxes_amount']) && bccomp($shippingOrder['taxes_amount'], '0', 2) > 0;

        return $hasDuties || $hasTaxes;
    }

    /**
     * Check if shipping order includes a redemption fee.
     *
     * Redemption fees apply when a customer redeems vouchers for wine delivery,
     * as opposed to simply shipping their own wine from custody.
     *
     * @param  array{redemption_fee?: array{amount: string}, is_redemption?: bool}  $shippingOrder
     */
    public function hasRedemptionFee(array $shippingOrder): bool
    {
        return isset($shippingOrder['redemption_fee']['amount'])
            && bccomp($shippingOrder['redemption_fee']['amount'], '0', 2) > 0;
    }

    /**
     * Check if shipping order is a redemption shipment (vs shipping-only).
     *
     * A redemption shipment involves voucher redemption for wine delivery,
     * while shipping-only is when a customer ships their own wine from custody.
     *
     * @param  array{redemption_fee?: array{amount: string}, is_redemption?: bool}  $shippingOrder
     */
    public function isRedemptionShipment(array $shippingOrder): bool
    {
        // Either explicitly marked as redemption or has redemption fee
        if (isset($shippingOrder['is_redemption']) && $shippingOrder['is_redemption'] === true) {
            return true;
        }

        return $this->hasRedemptionFee($shippingOrder);
    }

    /**
     * Check if shipping order is shipping-only (no redemption).
     *
     * @param  array{redemption_fee?: array{amount: string}, is_redemption?: bool}  $shippingOrder
     */
    public function isShippingOnly(array $shippingOrder): bool
    {
        return ! $this->isRedemptionShipment($shippingOrder);
    }

    /**
     * Get the shipment type as a string.
     *
     * @param  array{redemption_fee?: array{amount: string}, is_redemption?: bool}  $shippingOrder
     */
    public function getShipmentType(array $shippingOrder): string
    {
        return $this->isRedemptionShipment($shippingOrder) ? 'redemption' : 'shipping_only';
    }
}
