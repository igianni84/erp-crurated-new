<?php

namespace App\Models\Commercial;

use App\Enums\Commercial\ExecutionCadence;
use App\Enums\Commercial\PricingPolicyInputSource;
use App\Enums\Commercial\PricingPolicyStatus;
use App\Enums\Commercial\PricingPolicyType;
use App\Traits\Auditable;
use App\Traits\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Database\Eloquent\SoftDeletes;

/**
 * PricingPolicy Model
 *
 * Represents an automated pricing policy for generating prices.
 * Policies define rules for calculating prices based on various inputs
 * (cost, EMP, reference price book, external index) and apply them
 * to a target Price Book.
 *
 * Status transitions:
 * - draft → active
 * - active → paused
 * - paused → active
 * - active/paused → archived
 *
 * Policies generate draft prices, they never activate them directly.
 *
 * @property string $id
 * @property string $name
 * @property PricingPolicyType $policy_type
 * @property PricingPolicyInputSource $input_source
 * @property string|null $target_price_book_id
 * @property array<string, mixed> $logic_definition
 * @property ExecutionCadence $execution_cadence
 * @property PricingPolicyStatus $status
 * @property \Carbon\Carbon|null $last_executed_at
 */
class PricingPolicy extends Model
{
    use Auditable;
    use HasFactory;
    use HasUuid;
    use SoftDeletes;

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'pricing_policies';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'policy_type',
        'input_source',
        'target_price_book_id',
        'logic_definition',
        'execution_cadence',
        'status',
        'last_executed_at',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'policy_type' => PricingPolicyType::class,
            'input_source' => PricingPolicyInputSource::class,
            'logic_definition' => 'array',
            'execution_cadence' => ExecutionCadence::class,
            'status' => PricingPolicyStatus::class,
            'last_executed_at' => 'datetime',
        ];
    }

    /**
     * Get the target price book that this policy generates prices for.
     *
     * @return BelongsTo<PriceBook, $this>
     */
    public function targetPriceBook(): BelongsTo
    {
        return $this->belongsTo(PriceBook::class, 'target_price_book_id');
    }

    /**
     * Get the audit logs for this pricing policy.
     *
     * @return MorphMany<\App\Models\AuditLog, $this>
     */
    public function auditLogs(): MorphMany
    {
        return $this->morphMany(\App\Models\AuditLog::class, 'auditable');
    }

    /**
     * Get the price book entries generated by this policy.
     *
     * @return HasMany<PriceBookEntry, $this>
     */
    public function generatedEntries(): HasMany
    {
        return $this->hasMany(PriceBookEntry::class, 'policy_id');
    }

    /**
     * Check if the policy is in draft status.
     */
    public function isDraft(): bool
    {
        return $this->status === PricingPolicyStatus::Draft;
    }

    /**
     * Check if the policy is active.
     */
    public function isActive(): bool
    {
        return $this->status === PricingPolicyStatus::Active;
    }

    /**
     * Check if the policy is paused.
     */
    public function isPaused(): bool
    {
        return $this->status === PricingPolicyStatus::Paused;
    }

    /**
     * Check if the policy is archived.
     */
    public function isArchived(): bool
    {
        return $this->status === PricingPolicyStatus::Archived;
    }

    /**
     * Check if the policy can be activated.
     * Must be in draft status to be activated.
     */
    public function canBeActivated(): bool
    {
        return $this->isDraft();
    }

    /**
     * Check if the policy can be paused.
     * Must be active to be paused.
     */
    public function canBePaused(): bool
    {
        return $this->isActive();
    }

    /**
     * Check if the policy can be resumed (unpaused).
     * Must be paused to be resumed.
     */
    public function canBeResumed(): bool
    {
        return $this->isPaused();
    }

    /**
     * Check if the policy can be archived.
     * Must be active or paused to be archived.
     */
    public function canBeArchived(): bool
    {
        return $this->isActive() || $this->isPaused();
    }

    /**
     * Check if the policy is editable.
     * Only draft policies can be edited.
     */
    public function isEditable(): bool
    {
        return $this->isDraft();
    }

    /**
     * Check if the policy can be executed.
     * Must be active to be executed (except dry-run).
     */
    public function canBeExecuted(): bool
    {
        return $this->isActive();
    }

    /**
     * Check if a dry-run can be performed on the policy.
     * Dry-run is available for any non-archived policy.
     */
    public function canDryRun(): bool
    {
        return ! $this->isArchived();
    }

    /**
     * Check if the policy has been executed at least once.
     */
    public function hasBeenExecuted(): bool
    {
        return $this->last_executed_at !== null;
    }

    /**
     * Check if the policy is scheduled for execution.
     */
    public function isScheduled(): bool
    {
        return $this->execution_cadence === ExecutionCadence::Scheduled;
    }

    /**
     * Check if the policy is event-triggered.
     */
    public function isEventTriggered(): bool
    {
        return $this->execution_cadence === ExecutionCadence::EventTriggered;
    }

    /**
     * Check if the policy is manual execution only.
     */
    public function isManualExecution(): bool
    {
        return $this->execution_cadence === ExecutionCadence::Manual;
    }

    /**
     * Get the margin percentage from logic definition.
     */
    public function getMarginPercentage(): ?float
    {
        return $this->logic_definition['margin_percentage'] ?? null;
    }

    /**
     * Get the markup value from logic definition.
     */
    public function getMarkupValue(): ?float
    {
        return $this->logic_definition['markup_value'] ?? null;
    }

    /**
     * Get the rounding rule from logic definition.
     */
    public function getRoundingRule(): ?string
    {
        return $this->logic_definition['rounding_rule'] ?? null;
    }

    /**
     * Get the tiered logic from logic definition.
     *
     * @return array<string, mixed>|null
     */
    public function getTieredLogic(): ?array
    {
        return $this->logic_definition['tiered_logic'] ?? null;
    }

    /**
     * Get the status color for UI display.
     */
    public function getStatusColor(): string
    {
        return $this->status->color();
    }

    /**
     * Get the status label for UI display.
     */
    public function getStatusLabel(): string
    {
        return $this->status->label();
    }

    /**
     * Get the policy type color for UI display.
     */
    public function getPolicyTypeColor(): string
    {
        return $this->policy_type->color();
    }

    /**
     * Get the policy type label for UI display.
     */
    public function getPolicyTypeLabel(): string
    {
        return $this->policy_type->label();
    }

    /**
     * Get the input source color for UI display.
     */
    public function getInputSourceColor(): string
    {
        return $this->input_source->color();
    }

    /**
     * Get the input source label for UI display.
     */
    public function getInputSourceLabel(): string
    {
        return $this->input_source->label();
    }

    /**
     * Get the execution cadence color for UI display.
     */
    public function getExecutionCadenceColor(): string
    {
        return $this->execution_cadence->color();
    }

    /**
     * Get the execution cadence label for UI display.
     */
    public function getExecutionCadenceLabel(): string
    {
        return $this->execution_cadence->label();
    }

    /**
     * Get a plain-language description of the policy logic.
     */
    public function getLogicDescription(): string
    {
        $description = '';

        switch ($this->policy_type) {
            case PricingPolicyType::CostPlusMargin:
                $margin = $this->getMarginPercentage();
                $description = $margin !== null
                    ? "Cost + {$margin}% margin"
                    : 'Cost + margin (not configured)';
                break;

            case PricingPolicyType::ReferencePriceBook:
                $markup = $this->getMarkupValue();
                $description = $markup !== null
                    ? "Reference Price Book + {$markup}% adjustment"
                    : 'Reference Price Book (no adjustment)';
                break;

            case PricingPolicyType::IndexBased:
                $description = "Based on {$this->input_source->label()}";
                break;

            case PricingPolicyType::FixedAdjustment:
                $markup = $this->getMarkupValue();
                if ($markup !== null) {
                    $description = $markup >= 0
                        ? "+{$markup}% adjustment"
                        : "{$markup}% adjustment";
                } else {
                    $description = 'Fixed adjustment (not configured)';
                }
                break;

            case PricingPolicyType::Rounding:
                $rule = $this->getRoundingRule();
                $description = $rule !== null
                    ? "Round to {$rule}"
                    : 'Rounding (not configured)';
                break;
        }

        // Add rounding if present (and not already a rounding policy)
        if ($this->policy_type !== PricingPolicyType::Rounding) {
            $rounding = $this->getRoundingRule();
            if ($rounding !== null) {
                $description .= ", rounded to {$rounding}";
            }
        }

        return $description;
    }
}
