# Ralph Progress Log
Started: Wed Feb  4 14:00:43 CET 2026

## Codebase Patterns
- Use `$table->uuid('id')->primary()` for model primary keys with HasUuid trait
- Models use Auditable trait with created_by/updated_by foreign keys to users
- Enums follow pattern: value cases with label(), color(), icon() methods
- Inventory module: app/Models/Inventory/, app/Enums/Inventory/, app/Services/Inventory/
- Module B branch is based on ralph/module-a-allocations branch
- Services throw InvalidArgumentException for validation errors

---

## 2026-02-04 - US-B001
- **Implemented**: Location model as base for physical storage management
- **Files created**:
  - app/Enums/Inventory/LocationType.php (5 location types with label/color/icon methods)
  - app/Enums/Inventory/LocationStatus.php (3 statuses with operational methods)
  - app/Models/Inventory/Location.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100000_create_locations_table.php
- **Learnings for future iterations**:
  - Location model relationships to InboundBatch, SerializedBottle, InventoryCase were deferred as those models don't exist yet
  - The serialization_authorized flag is key for US-B022 (serialization location blocker)
  - LocationStatus.canReceiveInventory() and canDispatchInventory() will be used by movement validation
---

## 2026-02-04 - US-B002
- **Implemented**: 8 inventory-related enums for Module B
- **Files created**:
  - app/Enums/Inventory/InboundBatchStatus.php (pending_serialization, partially_serialized, fully_serialized, discrepancy)
  - app/Enums/Inventory/BottleState.php (stored, reserved_for_picking, shipped, consumed, destroyed, missing)
  - app/Enums/Inventory/CaseIntegrityStatus.php (intact, broken)
  - app/Enums/Inventory/MovementType.php (internal_transfer, consignment_placement, consignment_return, event_shipment, event_consumption)
  - app/Enums/Inventory/MovementTrigger.php (wms_event, erp_operator, system_automatic)
  - app/Enums/Inventory/OwnershipType.php (crurated_owned, in_custody, third_party_owned)
  - app/Enums/Inventory/ConsumptionReason.php (event_consumption, sampling, damage_writeoff)
  - app/Enums/Inventory/DiscrepancyResolution.php (shortage, overage, damage, other)
- **Learnings for future iterations**:
  - LocationType and LocationStatus were already created in US-B001
  - Each enum includes helper methods beyond label/color/icon (e.g., canStartSerialization(), isAvailableForFulfillment())
  - InboundBatchStatus.canStartSerialization() will be key for serialization flow (US-B020-B023)
  - BottleState.isAvailableForFulfillment() and isTerminal() will be used by inventory service
  - CaseIntegrityStatus.canHandleAsUnit() will prevent operations on broken cases
  - OwnershipType.canConsumeForEvents() enforces only crurated_owned items can be consumed
---

## 2026-02-04 - US-B003
- **Implemented**: InboundBatch model as physical receipt record bridging procurement to serialized inventory
- **Files created**:
  - app/Models/Inventory/InboundBatch.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100001_create_inbound_batches_table.php
- **Relationships**:
  - belongsTo Location (receiving_location_id) - where batch is received
  - belongsTo Allocation (allocation_id) - preserves allocation lineage
  - morphTo productReference - polymorphic reference to wine product
- **Key fields**:
  - source_type (producer/supplier/transfer)
  - quantity_expected vs quantity_received for discrepancy tracking
  - serialization_status (uses InboundBatchStatus enum)
  - ownership_type (uses OwnershipType enum)
- **Learnings for future iterations**:
  - InboundBatch.allocation_id is the source of allocation lineage for all SerializedBottles created from it
  - getRemainingUnserializedAttribute() will need to count SerializedBottles when that model exists
  - canStartSerialization() checks both status and location.canSerialize()
  - hasDiscrepancy() compares expected vs received quantities
  - procurement_intent_id FK is nullable since ProcurementIntent model doesn't exist yet (Module D)
---

## 2026-02-04 - US-B004
- **Implemented**: SerializedBottle model as first-class object with unique identity
- **Files created**:
  - app/Models/Inventory/SerializedBottle.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100002_create_serialized_bottles_table.php
- **Files modified**:
  - app/Models/Inventory/InboundBatch.php (added serializedBottles relationship, updated getRemainingUnserializedAttribute)
  - app/Models/Inventory/Location.php (added serializedBottles and inboundBatches relationships)
- **Relationships**:
  - belongsTo WineVariant (wine_variant_id)
  - belongsTo Format (format_id)
  - belongsTo Allocation (allocation_id) - IMMUTABLE
  - belongsTo InboundBatch (inbound_batch_id)
  - belongsTo Location (current_location_id)
  - belongsTo InventoryCase (case_id) - nullable, model created in US-B005
- **Key immutability enforcement**:
  - serial_number: unique, cannot be changed after creation (DB constraint + model boot guard)
  - allocation_id: cannot be changed after creation (model boot guard)
  - Immutable fields throw InvalidArgumentException on modification attempt
- **Learnings for future iterations**:
  - InventoryCase model doesn't exist yet (US-B005), used @phpstan-ignore for case() relationship
  - Foreign key to cases table will be added when cases migration is created
  - InboundBatch.getRemainingUnserializedAttribute() now correctly counts serialized bottles
  - SerializedBottle.canConsumeForEvents() checks ownership_type.canConsumeForEvents() AND isStored()
  - All state-checking helper methods (isStored, isShipped, etc.) delegate to BottleState enum
---

## 2026-02-04 - US-B005
- **Implemented**: InventoryCase model as physical container for bottles
- **Files created**:
  - app/Models/Inventory/InventoryCase.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100003_create_cases_table.php
- **Files modified**:
  - app/Models/Inventory/SerializedBottle.php (updated case() relationship to use InventoryCase class)
  - app/Models/Inventory/Location.php (added cases() relationship)
  - app/Models/Inventory/InboundBatch.php (added cases() relationship)
- **Relationships**:
  - belongsTo CaseConfiguration (case_configuration_id)
  - belongsTo Allocation (allocation_id) - allocation lineage
  - belongsTo InboundBatch (inbound_batch_id) - nullable
  - belongsTo Location (current_location_id)
  - hasMany SerializedBottle (via case_id FK)
- **Key integrity enforcement**:
  - integrity_status: BROKEN cannot revert to INTACT (model boot guard throws InvalidArgumentException)
  - Breaking is irreversible per US-B052
- **Learnings for future iterations**:
  - Model named InventoryCase (not Case) to avoid PHP reserved keyword
  - Table is named 'cases' while model is InventoryCase
  - FK from serialized_bottles.case_id to cases.id added in this migration
  - canBreak() checks is_breakable AND isIntact() for Break Case action (US-B032)
  - bottle_count accessor counts related serializedBottles
---

## 2026-02-04 - US-B006
- **Implemented**: InventoryMovement model as immutable record of physical inventory events
- **Files created**:
  - app/Models/Inventory/InventoryMovement.php (HasUuid only, NO Auditable, NO SoftDeletes)
  - database/migrations/2026_02_04_100004_create_inventory_movements_table.php
- **Relationships**:
  - belongsTo Location (source_location_id) - nullable
  - belongsTo Location (destination_location_id) - nullable
  - belongsTo User (executed_by) - nullable
  - hasMany MovementItem (inventory_movement_id) - model created in US-B007
- **Key immutability enforcement**:
  - NO soft deletes - movements are never deleted
  - Model boot guard throws InvalidArgumentException on update attempt
  - Model boot guard throws InvalidArgumentException on delete attempt
  - Movements are append-only (insert only)
- **WMS deduplication**:
  - wms_event_id is unique nullable for deduplication
- **Learnings for future iterations**:
  - InventoryMovement does NOT use Auditable trait (movements ARE the audit log)
  - MovementItem model doesn't exist yet (US-B007), used @phpstan-ignore for relationship
  - MovementType and MovementTrigger enums already exist from US-B002
  - Helper methods delegate to enums (isWmsTriggered, isTransfer, isConsumption)
  - items_count accessor counts related movementItems
---

## 2026-02-04 - US-B007
- **Implemented**: MovementItem model as detail of items involved in inventory movements
- **Files created**:
  - app/Models/Inventory/MovementItem.php (NO Auditable, NO SoftDeletes, NO HasUuid)
  - database/migrations/2026_02_04_100005_create_movement_items_table.php
- **Files modified**:
  - app/Models/Inventory/InventoryMovement.php (removed @phpstan-ignore, fixed relationship return type)
- **Relationships**:
  - belongsTo InventoryMovement (inventory_movement_id) - required
  - belongsTo SerializedBottle (serialized_bottle_id) - nullable
  - belongsTo InventoryCase (case_id) - nullable
- **Key immutability enforcement**:
  - NO soft deletes - items are never deleted
  - Model boot guard throws InvalidArgumentException on update attempt
  - Model boot guard throws InvalidArgumentException on delete attempt
  - Items are append-only (insert only)
- **Validation**:
  - Creating hook validates at least one of serialized_bottle_id or case_id is set
- **Learnings for future iterations**:
  - MovementItem uses standard auto-incrementing id (not UUID) since it's not a standalone entity
  - MovementItem does NOT use Auditable (parent InventoryMovement is the audit record)
  - Helper methods hasBottle() and hasCase() for quick type checking
  - Uses cascadeOnDelete on inventory_movement_id FK (if parent is somehow deleted, items go too)
  - Uses nullOnDelete on serialized_bottle_id and case_id (item stays, reference becomes null)
---

## 2026-02-04 - US-B008
- **Implemented**: InventoryException model for recording inventory exceptions and audit trail
- **Files created**:
  - app/Models/Inventory/InventoryException.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100006_create_inventory_exceptions_table.php
- **Relationships**:
  - belongsTo SerializedBottle (serialized_bottle_id) - nullable
  - belongsTo InventoryCase (case_id) - nullable
  - belongsTo InboundBatch (inbound_batch_id) - nullable
  - belongsTo User (created_by) - required, the creator
  - belongsTo User (resolved_by) - nullable, the resolver
- **Key fields**:
  - exception_type: string (e.g., 'shortage', 'overage', 'damage', 'committed_consumption_override')
  - reason: required text explaining the exception
  - resolution: nullable text filled when resolved
  - resolved_at: timestamp for when exception was resolved
- **Helper methods**:
  - isResolved(), isPending() for checking resolution status
  - hasBottle(), hasCase(), hasInboundBatch() for checking related entities
- **Learnings for future iterations**:
  - InventoryException is used by US-B047 (Committed inventory consumption override) to flag exceptions for finance & ops review
  - The exception_type field is a string (not enum) for flexibility in exception types
  - Both creator and resolver relationships point to User model
  - Uses Auditable trait for created_by/updated_by audit trail
---

## 2026-02-04 - US-B009
- **Implemented**: InventoryService for centralized inventory logic
- **Files created**:
  - app/Services/Inventory/InventoryService.php
- **Methods implemented**:
  - getCommittedQuantity(Allocation): count unredeemed vouchers (Issued + Locked states)
  - getFreeQuantity(Allocation): physical bottles (stored state) - committed quantity
  - canConsume(SerializedBottle): checks if bottle can be consumed for events
  - getBottlesAtLocation(Location): returns stored bottles at a location
  - getBottlesByAllocationLineage(Allocation): returns all bottles for an allocation
- **Key logic**:
  - Committed = Vouchers in Issued or Locked lifecycle_state (NOT redeemed/cancelled)
  - Physical bottles = SerializedBottles in 'stored' state
  - canConsume checks: stored state, ownership_type.canConsumeForEvents(), free quantity > 0
- **Learnings for future iterations**:
  - Services go in app/Services/Inventory/ directory for inventory module
  - VoucherLifecycleState.Issued and .Locked are the unredeemed states
  - BottleState.Stored is the only state considered for physical availability
  - Bottle-to-voucher binding doesn't exist yet, so canConsume checks at allocation level
---

## 2026-02-04 - US-B010
- **Implemented**: SerializationService for centralized serialization logic
- **Files created**:
  - app/Services/Inventory/SerializationService.php
  - app/Jobs/Inventory/MintProvenanceNftJob.php (for async NFT minting)
- **Methods implemented**:
  - canSerializeAtLocation(Location): delegates to Location.canSerialize()
  - serializeBatch(InboundBatch, int, User): creates SerializedBottle records with full validation
  - generateSerialNumber(): generates unique CRU-YYYYMMDD-XXXXXXXX format serial numbers
  - queueNftMinting(SerializedBottle): dispatches MintProvenanceNftJob
  - updateBatchSerializationStatus(InboundBatch): updates status to pending/partial/fully_serialized
- **Key validation in serializeBatch**:
  - Quantity > 0
  - Batch.canStartSerialization() = true
  - Quantity <= remaining unserialized
  - Location.canSerialize() = true
  - Batch has allocation lineage (for immutable propagation)
  - Batch has product reference
- **Allocation lineage invariant**:
  - allocation_id is propagated from InboundBatch to every SerializedBottle created
  - This is immutable after creation (enforced in SerializedBottle model)
- **MintProvenanceNftJob**:
  - Uses exponential backoff: 10s, 60s, 300s
  - Max 3 attempts
  - Updates bottle.nft_reference and bottle.nft_minted_at on success
  - Placeholder implementation for actual blockchain integration
- **Learnings for future iterations**:
  - Jobs go in app/Jobs/Inventory/ directory for inventory module
  - Serial number format: CRU-{YYYYMMDD}-{8 random chars}
  - NFT minting is decoupled from serialization (async job)
  - getDefaultFormatId() needs UI improvement to select format explicitly
  - Discrepancy status is NOT changed by updateBatchSerializationStatus (handled separately)
---

## 2026-02-04 - US-B011
- **Implemented**: MovementService for centralized inventory movement logic
- **Files created**:
  - app/Services/Inventory/MovementService.php
- **Methods implemented**:
  - createMovement(array $data): creates InventoryMovement with MovementItems in a transaction
  - isDuplicateWmsEvent(string $wmsEventId): checks if WMS event already processed (deduplication)
  - transferBottle(SerializedBottle, Location, ?User, ?reason, ?wmsEventId): creates internal transfer and updates bottle location
  - transferCase(InventoryCase, Location, ?User, ?reason, ?wmsEventId): creates internal transfer and updates case + contained bottles locations
  - recordConsumption(SerializedBottle, ConsumptionReason, ?User, ?notes): creates consumption movement and updates bottle state to consumed
- **Key validations**:
  - createMovement: validates required fields, checks WMS event deduplication
  - transferBottle: validates bottle not in terminal state, has current location, not transferring to same location
  - transferCase: validates case canHandleAsUnit (not broken), has current location, not transferring to same location
  - recordConsumption: validates bottle is stored, ownership allows consumption for events
- **Transaction safety**:
  - All methods use DB::transaction to ensure movement creation + location/state updates are atomic
- **Learnings for future iterations**:
  - MovementType::EventConsumption is used for all consumption types (sampling, damage writeoff, event)
  - Trigger is automatically determined: WmsEvent if wms_event_id provided, otherwise ErpOperator
  - Case transfer also updates all contained bottles' locations via batch update
  - Terminal states (consumed, destroyed, missing, shipped) block bottle transfers
---

## 2026-02-04 - US-B012
- **Implemented**: LocationResource in Filament for managing physical storage points
- **Files created**:
  - app/Filament/Resources/Inventory/LocationResource.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/ListLocations.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/CreateLocation.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/ViewLocation.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/EditLocation.php
- **Features implemented**:
  - Navigation group: Inventory (sort order 1)
  - List columns: name, location_type (badge), country, serialization_authorized (icon), linked_wms_id (badge), status (badge), stock_summary, updated_at
  - Filters: location_type (multi-select), country (searchable), serialization_authorized (ternary), status (with Active default), TrashedFilter
  - Search: name and country fields are searchable
  - Visual indicator for WMS: badge shows "Linked" (info color) or "Not Linked" (gray) with link icon
  - Stock summary shows count of serialized bottles at location via withCount
- **Learnings for future iterations**:
  - Filament Resources for Inventory module go in app/Filament/Resources/Inventory/ directory
  - Navigation group 'Inventory' is used for all Module B Filament resources
  - Use withCount() and custom state() for computed columns like stock_summary
  - Use formatStateUsing() with enum's label(), color(), icon() methods for enum columns
  - TrashedFilter requires getEloquentQuery() to remove SoftDeletingScope
  - View and Edit pages are placeholders for US-B013 and US-B014 respectively
---

## 2026-02-04 - US-B013
- **Implemented**: Location Detail page with 4 tabs for comprehensive location management
- **Files modified**:
  - app/Filament/Resources/Inventory/LocationResource/Pages/ViewLocation.php (complete rewrite)
- **Features implemented**:
  - Prominent serialization warning banner at top when serialization_authorized = false
  - Tab 1: Overview - Location identity, stock summary (serialized bottles, cases, unserialized inbound), bottles by state breakdown, ownership breakdown by type
  - Tab 2: Inventory - Paginated list of SerializedBottles with serial number/wine/format/state/ownership, list of Cases with configuration/integrity/bottles count
  - Tab 3: Inbound/Outbound - Recent InboundBatches with status, recent transfers in/out from InventoryMovement records
  - Tab 4: WMS Status - Connection status badge, WMS ID, last sync timestamp from WMS-triggered movements, error logs section (read-only)
- **Key patterns used**:
  - Tabs::make() with persistTabInQueryString() for tab persistence in URL
  - TextEntry with getStateUsing() for computed values and aggregations
  - RepeatableEntry for displaying related models (bottles, cases, batches)
  - Section with visible() for conditional display (e.g., WMS sections)
  - HTML generation within TextEntry for custom movement displays
- **Learnings for future iterations**:
  - PHPStan requires explicit null checks for nullable relations - use `$relation !== null ? ... : ...` pattern instead of `?->` with `??`
  - For eager-loaded relations that may not exist, assign to variable first then check null
  - executed_at on InventoryMovement is non-nullable (required field), so no null checks needed
  - Section::extraAttributes() can add custom styling classes like bg-danger-50 for warning sections
  - RepeatableEntry columns(1) forces vertical layout for better readability
  - Browser verification requirement noted - manual testing needed
---

## 2026-02-04 - US-B014
- **Implemented**: Create/Edit Location forms in Filament
- **Files modified**:
  - app/Filament/Resources/Inventory/LocationResource.php (added complete form schema)
  - app/Filament/Resources/Inventory/LocationResource/Pages/CreateLocation.php (added redirect to view)
  - app/Filament/Resources/Inventory/LocationResource/Pages/EditLocation.php (added beforeSave warning, redirect to view)
- **Features implemented**:
  - Form sections: Location Details (name, location_type, country, address), Settings (serialization_authorized, linked_wms_id, status), Notes (collapsible)
  - Name uniqueness validation with `withoutTrashed()` modifier
  - Prominent warning banner when disabling serialization_authorized on location with pending serialization batches
  - Live reactive toggle for serialization_authorized to show/hide warning dynamically
  - Notification sent on save when disabling serialization with pending batches
  - Redirect to view page after create/edit
- **Audit logging**:
  - Handled automatically by Auditable trait on Location model
  - All create/update/delete events logged to AuditLog table
- **Learnings for future iterations**:
  - Use `Forms\Get $get` with `->live()` on toggle to make warning section reactive
  - `->unique(modifyRuleUsing: fn (Unique $rule) => $rule->withoutTrashed())` ensures soft-deleted records don't conflict with uniqueness
  - `beforeSave()` hook in EditRecord is ideal for validation warnings that don't block save
  - Section::make()->extraAttributes() adds custom CSS classes for visual prominence
  - Browser verification requirement noted - manual testing needed
---

## 2026-02-04 - US-B015
- **Implemented**: InboundBatchResource in Filament for managing inbound batches
- **Files created**:
  - app/Filament/Resources/Inventory/InboundBatchResource.php
  - app/Filament/Resources/Inventory/InboundBatchResource/Pages/ListInboundBatches.php
  - app/Filament/Resources/Inventory/InboundBatchResource/Pages/ViewInboundBatch.php
- **Features implemented**:
  - Navigation group: Inventory (sort order 2)
  - List columns: batch_id, source (badge), product_reference, quantity_expected, quantity_received (colored for discrepancy), packaging, receiving_location, received_date, serialization_status (badge), ownership_type (badge)
  - Visual indicators: IconColumn for discrepancy (red triangle), IconColumn for pending serialization (yellow clock)
  - Row highlighting: red background for discrepancy status, yellow for pending serialization
  - Filters: serialization_status (multi-select), receiving_location (searchable), ownership_type (multi-select), received_date range (from/until), has_discrepancy toggle, TrashedFilter
  - Search: batch_id, product_reference_id (via product_reference column)
- **Key patterns used**:
  - recordClasses() for conditional row styling based on status
  - IconColumn with state() callback for computed boolean columns
  - Filter::make() with form() for date range filters
  - indicateUsing() for filter indicator badges
  - withoutGlobalScopes() for soft delete handling
  - Eager loading receivingLocation relationship for performance
- **Learnings for future iterations**:
  - Use recordClasses() for row-level visual indicators (e.g., highlighting danger rows)
  - IconColumn with state() callback allows computed boolean indicators without model accessor
  - Date range filters use Filter::make() with form() containing two DatePicker components
  - indicateUsing() returns array of indicator strings for active filters
  - quantity_received column uses color() callback to show green/red based on discrepancy
  - Browser verification requirement noted - manual testing needed
---

## 2026-02-04 - US-B016
- **Implemented**: ViewInboundBatch page with 5 comprehensive tabs
- **Files modified**:
  - app/Filament/Resources/Inventory/InboundBatchResource/Pages/ViewInboundBatch.php (complete rewrite)
- **Features implemented**:
  - Tab 1 - Summary: Batch identity, source type, packaging, received date, sourcing context (procurement intent), allocation lineage (immutable, prominent), ownership type, receiving location
  - Tab 2 - Quantities: Expected vs received, serialized count, remaining unserialized, delta analysis with explanation, serialization progress
  - Tab 3 - Serialization: Eligibility check with detailed blocking reasons, serialization history grouped by date, serialized bottles list with state/location/NFT status
  - Tab 4 - Linked Physical Objects: Bottles by state breakdown, full SerializedBottles list, Cases list
  - Tab 5 - Audit Log: WMS events status, operator actions timeline, discrepancy resolutions section
  - Contextual actions: Start Serialization (visible when eligible), Resolve Discrepancy (visible when discrepancy exists)
  - Warning banners for discrepancy status and serialization-not-authorized locations
- **Key patterns used**:
  - getTitle() override for dynamic page title
  - infolist() with Tabs component and persistTabInQueryString()
  - Multiple Section components with conditional visibility via visible()
  - RepeatableEntry for displaying related models (bottles, cases)
  - TextEntry with getStateUsing() and html() for custom HTML content
  - Actions\Action with requiresConfirmation() and form() for modal actions
  - SerializationService integration for Start Serialization action
- **Learnings for future iterations**:
  - Use getAttribute() with explicit PHPDoc type annotation when PHPStan has issues with cast types
  - Actions in getHeaderActions() can use visible() callback based on record state
  - Resolve Discrepancy action updates status and appends resolution to condition_notes (preserves original data)
  - refreshFormData() can be used to update specific fields after action completes
  - HTML in TextEntry using heredoc syntax for complex layouts
  - Browser verification requirement noted - manual testing needed
---

## 2026-02-04 - US-B017
- **Implemented**: Discrepancy Resolution flow with immutable correction events
- **Files modified**:
  - app/Models/Inventory/InboundBatch.php (added relationships)
  - app/Filament/Resources/Inventory/InboundBatchResource/Pages/ViewInboundBatch.php (added Discrepancy Resolution tab, enhanced action)
- **Features implemented**:
  - Dedicated Discrepancy Resolution tab (visible only when quantity_expected != quantity_received)
  - Side-by-side comparison: Expected Quantity vs Received Quantity with source info
  - Discrepancy Analysis section with type (OVERAGE/SHORTAGE), amount, and serialization blocked status
  - Resolution History section displaying InventoryException records
  - Original Values Preserved section (collapsible) showing immutable baseline
  - Enhanced Resolve Discrepancy action:
    - Uses DiscrepancyResolution enum for resolution types (shortage, overage, damage, other)
    - Creates immutable InventoryException record (correction event) instead of appending to condition_notes
    - Preserves original values (delta record approach)
    - Audit confirmation checkbox required
    - Full context in reason (delta, expected, received)
  - Resolution history with visual indicators per type
- **Model changes**:
  - Added inventoryExceptions() HasMany relationship to InboundBatch
  - Added discrepancyResolutions() filtered HasMany for discrepancy-specific exceptions
- **Key patterns used**:
  - Tab visibility controlled by record state (hasDiscrepancy())
  - InventoryException as immutable correction event (not modifying original values)
  - discrepancyResolutions() filters by exception_type prefix 'discrepancy_'
  - HTML generation for resolution history with color-coded badges
  - Checkbox confirmation for audit trail awareness
- **Learnings for future iterations**:
  - InventoryException model is used for various exception types (not just discrepancies)
  - exception_type string field allows flexible categorization (e.g., 'discrepancy_shortage', 'discrepancy_overage')
  - Original values (quantity_expected, quantity_received) are NEVER modified - only serialization_status changes
  - Resolution creates both exception record AND updates batch status atomically
  - Browser verification requirement noted - manual testing needed
---

## 2026-02-04 - US-B018
- **Implemented**: Manual Inbound Batch creation with admin-only permission gate
- **Files created**:
  - app/Filament/Resources/Inventory/InboundBatchResource/Pages/CreateInboundBatch.php
- **Files modified**:
  - app/Filament/Resources/Inventory/InboundBatchResource.php (added complete form schema, canCreate permission gate)
  - app/Filament/Resources/Inventory/InboundBatchResource/Pages/ListInboundBatches.php (added create button with admin visibility)
- **Features implemented**:
  - Admin-only permission gate via canCreate() using User.isAdmin() (checks for admin or super_admin role)
  - Prominent warning banner at top of form explaining manual creation is for exceptions only
  - Mandatory reason field (manual_creation_reason) with min 20 char validation
  - Full form sections:
    - Source Information: source_type, product_reference_type/id, allocation_id
    - Quantities: quantity_expected, quantity_received, packaging_type
    - Location & Ownership: receiving_location_id, ownership_type, received_date
    - Serialization: serialization_status (defaults to PendingSerialization)
    - Additional Information: wms_reference_id, condition_notes (collapsible)
    - Confirmation: audit_confirmation checkbox (required)
  - Manual creation reason stored in condition_notes with "[MANUAL CREATION - Reason: ...]" prefix
  - Create button styled with warning color to indicate exceptional action
- **Key patterns used**:
  - canCreate() override in Resource for permission gating
  - mutateFormDataBeforeCreate() for storing manual creation reason
  - Section extraAttributes for visual prominence (danger/warning background colors)
  - Forms\Components\Placeholder for warning banner content
  - Checkbox with accepted() validation for confirmation
- **Learnings for future iterations**:
  - OwnershipType enum has a typo: CururatedOwned (not CruratedOwned) - be careful with enum case names
  - canCreate() is the Filament way to gate resource creation permissions
  - Use visible() callback on CreateAction to match canCreate() logic
  - mutateFormDataBeforeCreate() runs before validation passes through to model
  - Browser verification requirement noted - manual testing needed
---

## 2026-02-04 - US-B019
- **Implemented**: Serialization Queue page for operators to manage serialization workflow
- **Files created**:
  - app/Filament/Pages/SerializationQueue.php (Filament Table Page with HasTable trait)
  - resources/views/filament/pages/serialization-queue.blade.php (Blade view with stats cards)
- **Features implemented**:
  - Navigation group: Inventory (sort order 3)
  - Statistics cards: Total batches in queue, Pending count, Partially done count, Total bottles to serialize
  - Table columns: batch_id, product, quantity_remaining_unserialized, receiving_location, allocation_lineage, serialization_status, ownership_type, received_date
  - Filters: Location (only serialization-authorized locations), Date range (received_from/received_until), Serialization status
  - Actions: "Serialize" button with modal form to start serialization, "View" link to InboundBatch detail page
  - Base query filters: Only pending_serialization or partially_serialized batches, only at locations with serialization_authorized = true
  - Auto-refresh every 30 seconds (poll)
  - Empty state with check-circle icon when queue is empty
- **Key patterns used**:
  - Filament Page with HasTable trait for table-based pages (not Resource)
  - getTableQuery() for base query with relationship constraints
  - Tables\Actions\Action with form() for inline serialization from queue
  - Statistics computed in getQueueStats() method and passed to blade view
  - Tables\Columns\TextColumn with getStateUsing() for computed columns
- **Learnings for future iterations**:
  - Use `Filament\Pages\Page implements HasTable` with `InteractsWithTable` trait for standalone table pages
  - For PHPStan with Collection->sum(), use explicit foreach loop instead of callback to avoid type issues
  - Location filter should only show serialization-authorized locations to match the base query filter
  - poll('30s') adds auto-refresh to keep queue updated
  - emptyStateHeading/Description/Icon customize the empty state display
  - Browser verification requirement noted - manual testing needed
---
