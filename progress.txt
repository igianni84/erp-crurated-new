# Ralph Progress Log
Started: Tue Feb  3 18:51:45 CET 2026
---

## Codebase Patterns
- Enums should be PHP 8.1+ backed enums with `label()`, `color()`, and `icon()` helper methods for Filament integration
- Allocation-related enums go in `app/Enums/Allocation/`
- Use wine_variant_id + format_id as bottle SKU reference (no separate BottleSku model exists)
- Jobs go in `app/Jobs/{Module}/` - schedule in `routes/console.php` using `Schedule::job()->everyMinute()`
- Services go in `app/Services/{Module}/` - use DB::transaction() with lockForUpdate() for atomic quantity operations
- Filament Resources go in `app/Filament/Resources/{Module}/` with Pages subdirectory - use enum methods for badge styling
- Filament Wizard forms: use `CreateRecord\Concerns\HasWizard` trait in CreateXxx page class, override `form()` and `getSteps()`

---

## 2026-02-03 - US-002
- What was implemented: Verified that all three allocation enums already exist and meet acceptance criteria
- Files verified (no changes needed):
  - `app/Enums/Allocation/AllocationSourceType.php`
  - `app/Enums/Allocation/AllocationSupplyForm.php`
  - `app/Enums/Allocation/AllocationStatus.php`
- **Learnings for future iterations:**
  - Enums were created as part of US-001 setup, so this story was already complete
  - AllocationStatus includes transition helpers: `allowedTransitions()`, `canTransitionTo()`, `allowsConstraintEditing()`, `allowsConsumption()`, `isTerminal()`
  - All enums follow Filament patterns with label/color/icon methods
---

## 2026-02-03 - US-003
- What was implemented: AllocationConstraint model for authoritative commercial constraints on allocations
- Files changed:
  - `database/migrations/2026_02_03_260000_create_allocation_constraints_table.php` (new)
  - `app/Models/Allocation/AllocationConstraint.php` (new)
  - `app/Models/Allocation/Allocation.php` (added hasOne relationship and auto-create on allocation creation)
- **Learnings for future iterations:**
  - AllocationConstraint is automatically created when an Allocation is created (via `created` event in Allocation model boot)
  - Constraints can only be edited when Allocation is in Draft status (validated in AllocationConstraint's `updating` event)
  - The `constraint()` relationship uses HasOne pattern; the FK is `allocation_id` on the constraints table with unique constraint
  - JSON array fields use `'array'` cast in Laravel and `@property array<string>|null` PHPDoc for PHPStan
  - Helper methods: `getAllChannels()`, `getAllCustomerTypes()` return available options; `isChannelAllowed()`, etc. for constraint checking
---

## 2026-02-03 - US-004
- What was implemented: LiquidAllocationConstraint model for liquid-specific allocation constraints
- Files changed:
  - `database/migrations/2026_02_03_270000_create_liquid_allocation_constraints_table.php` (new)
  - `app/Models/Allocation/LiquidAllocationConstraint.php` (new)
  - `app/Models/Allocation/Allocation.php` (added liquidConstraint() relationship and isLiquid()/isBottled() helpers)
- **Learnings for future iterations:**
  - LiquidAllocationConstraint has a `saving` event that validates `allocation.supply_form === AllocationSupplyForm::Liquid`
  - Unlike AllocationConstraint, LiquidAllocationConstraint is NOT auto-created on Allocation creation (only applicable for liquid allocations)
  - Both constraint models follow the same pattern: unique FK to allocation_id, `updating` event to prevent edits on non-Draft allocations
  - Added `isLiquid()` and `isBottled()` helper methods to Allocation model for easier supply_form checks
---

## 2026-02-03 - US-005
- What was implemented: TemporaryReservation model for temporary holds on allocation quantity to prevent overselling
- Files changed:
  - `database/migrations/2026_02_03_280000_create_temporary_reservations_table.php` (new)
  - `app/Models/Allocation/TemporaryReservation.php` (new)
  - `app/Enums/Allocation/ReservationContextType.php` (new) - checkout, negotiation, manual_hold
  - `app/Enums/Allocation/ReservationStatus.php` (new) - active, expired, cancelled, converted
  - `app/Jobs/Allocation/ExpireReservationsJob.php` (new) - scheduled job to expire reservations
  - `app/Models/Allocation/Allocation.php` (added temporaryReservations() and activeReservations() relationships)
  - `routes/console.php` (added scheduled job registration)
- **Learnings for future iterations:**
  - TemporaryReservation does NOT consume allocation - it only "blocks" quantity temporarily
  - ReservationStatus has `isActive()`, `isTerminal()`, `allowedTransitions()`, `canTransitionTo()` helpers like AllocationStatus
  - Model includes helper methods: `expire()`, `cancel()`, `convert()` for state transitions
  - Scopes `active()` and `needsExpiration()` are available for querying
  - Jobs go in `app/Jobs/{Module}/` directory structure
  - Laravel 11+ scheduling is done in `routes/console.php` using `Schedule::job()->everyMinute()`
---

## 2026-02-03 - US-006
- What was implemented: AllocationService for centralizing allocation business logic
- Files changed:
  - `app/Services/Allocation/AllocationService.php` (new)
- **Methods implemented:**
  - `activate(Allocation)`: draft → active transition
  - `close(Allocation)`: active/exhausted → closed transition
  - `consumeAllocation(Allocation, quantity)`: decrements remaining, increments sold with DB transaction locking
  - `checkAvailability(Allocation, quantity)`: checks if quantity is available (remaining - active_reservations >= quantity)
  - `getRemainingAvailable(Allocation)`: returns remaining - sum(active_reservations.quantity)
  - `canActivate(Allocation)`, `canClose(Allocation)`: helper methods for checking allowed transitions
  - `markAsExhausted(Allocation)`: active → exhausted transition (auto-called when remaining reaches 0)
- **Learnings for future iterations:**
  - Services go in `app/Services/{Module}/` directory structure
  - Use `DB::transaction()` with `lockForUpdate()` for atomic operations that modify quantities
  - Always double-check availability after acquiring lock to prevent race conditions
  - Status transitions should auto-trigger where appropriate (e.g., exhausted when remaining=0)
  - Use explicit exception messages that explain what's wrong and how to fix it
---

## 2026-02-03 - US-007
- What was implemented: AllocationResource for Filament admin panel with comprehensive list view
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/ListAllocations.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/ViewAllocation.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/EditAllocation.php` (new)
- **Features implemented:**
  - Navigation group 'Allocations' with cube-transparent icon
  - All required columns: id, bottle_sku, supply_form, source_type, status, total_qty, sold_qty, remaining_qty, availability_window, constraint_summary, updated_at
  - Status, source_type, supply_form shown as badges with colors and icons from enums
  - Near exhaustion indicator: remaining_qty shows danger color, bold text, and warning icon when < 10%
  - Filters: status (multi-select, default excludes Closed), source_type (multi-select), supply_form, wine_variant/bottle_sku, near_exhaustion toggle, trashed
  - Search: wine name, producer, allocation ID via searchable columns
  - Eager loading of relationships (wineVariant.wineMaster, format, constraint) via modifyQueryUsing
- **Learnings for future iterations:**
  - Filament Resources go in `app/Filament/Resources/{Module}/` with Pages subdirectory
  - Use `formatStateUsing()` with enum's `label()` method for badge text
  - Use `color()` and `icon()` from enum for badge styling
  - For computed columns, use `state()` callback to call model methods like `getBottleSkuLabel()`
  - For searchable computed columns, use `searchable(query: ...)` with custom query builder
  - Use `modifyQueryUsing()` on table for eager loading relationships
  - Default filter values with `->default()` to pre-populate filter (e.g., exclude Closed status)
---

## 2026-02-03 - US-008
- What was implemented: Create Allocation wizard - Step 1 (Bottle SKU selection)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (modified to add wizard)
- **Features implemented:**
  - Wizard-based form using `CreateRecord\Concerns\HasWizard` trait
  - Step 1: Bottle SKU selection with cascading selects:
    - Wine selection via autocomplete search (searches by name or producer)
    - Vintage selection (dynamically filtered by selected WineMaster)
    - Format selection (all available formats ordered by volume_ml)
  - Bottle SKU preview showing full label: Wine (Producer) Vintage - Format
  - Info message: "Allocation always happens at Bottle SKU level (Wine + Vintage + Format)"
  - `mutateFormDataBeforeCreate()` removes temporary wine_master_id field
- **Learnings for future iterations:**
  - Use `CreateRecord\Concerns\HasWizard` trait for multi-step forms
  - For cascading selects: use `live()` + `afterStateUpdated()` to reset dependent fields
  - Use `hidden()` with `Get` callback to show/hide sections based on previous selections
  - Use `getSearchResultsUsing()` for custom autocomplete search logic
  - Use `getOptionLabelUsing()` to format existing option labels for display
  - Use `getAttribute()` instead of direct property access to avoid PHPStan strict type errors
---

## 2026-02-03 - US-009
- What was implemented: Create Allocation wizard - Step 2 (Source & Capacity)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getSourceAndCapacityStep method)
- **Features implemented:**
  - Source Type select with all AllocationSourceType enum options (producer_allocation, owned_stock, passive_consignment, third_party_custody)
  - Supply Form select with AllocationSupplyForm enum options (bottled, liquid)
  - Live inline guidance explaining implications of bottled vs liquid supply:
    - Bottled: ready for sale, individual serialization
    - Liquid: still in barrel/tank, bottling options may apply, additional constraints in Step 4
  - Total Quantity numeric input with minValue(1) validation and "bottles" suffix
  - Availability Window with start/end date pickers, afterOrEqual validation for end date
  - Serialization Required toggle (default true) with live inline guidance:
    - Enabled: unique identifier for provenance tracking, recommended for fine wine
    - Disabled: bottles not individually tracked, for commodity wines only
- **Learnings for future iterations:**
  - Use `live()` on fields that need to update guidance Placeholders dynamically
  - Use `native(false)` on Select components for better Filament-styled dropdowns
  - Use `afterOrEqual()` validation on DatePicker for date range validation (cleaner than custom rules)
  - Placeholder components with markdown (**bold**) work for inline guidance
  - Each step method returns a Wizard\Step - add to getSteps() array
---

## 2026-02-03 - US-010
- What was implemented: Create Allocation wizard - Step 3 (Commercial Constraints)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getCommercialConstraintsStep method, updated getSteps, mutateFormDataBeforeCreate, and added afterCreate)
- **Features implemented:**
  - Step 3: Commercial Constraints with shield-check icon
  - Prominent warning message: "⚠️ AUTHORITATIVE CONSTRAINTS — These constraints are binding and will be enforced by Module S"
  - CheckboxList for allowed_channels with options: b2c, b2b, private_sales, wholesale, club (displayed in 2 columns)
  - TagsInput for allowed_geographies (flexible input for ISO country/region codes)
  - CheckboxList for allowed_customer_types with options: retail, trade, private_client, club_member, internal (displayed in 2 columns)
  - Helper text explaining default behavior: empty = all allowed
  - Info note about constraints becoming read-only after activation
  - Nested form data handling via session storage + afterCreate hook to update AllocationConstraint
- **Learnings for future iterations:**
  - Use `constraint.field_name` dot notation for nested related model fields in wizard forms
  - For related model data in creation wizards, use session storage in `mutateFormDataBeforeCreate()` and apply in `afterCreate()` hook
  - CheckboxList with `->columns(2)` for compact multi-select display
  - TagsInput is flexible for user-defined values (like geography codes) vs CheckboxList for predefined options
  - Use PHPDoc `@var` type hints to help PHPStan understand `$this->record` type in afterCreate
---

## 2026-02-03 - US-011
- What was implemented: Create Allocation wizard - Step 4 (Advanced/Liquid Constraints)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getAdvancedConstraintsStep method, updated getSteps, mutateFormDataBeforeCreate, and afterCreate)
- **Features implemented:**
  - Step 4: Advanced Constraints with adjustments-horizontal icon
  - Liquid Allocation Constraints section (visible/expanded only when supply_form = liquid):
    - allowed_bottling_formats (TagsInput) - customers can choose from specified formats
    - allowed_case_configurations (TagsInput) - packaging options for customers
    - bottling_confirmation_deadline (DatePicker) - deadline for bottling preferences
    - Inline guidance explaining liquid allocation requirements
  - Advanced Commercial Constraints section (always available, collapsed by default for bottled, expanded for liquid):
    - composition_constraint_group (TextInput) - for vertical cases and themed selections
    - fungibility_exception (Toggle) - for non-interchangeable bottles
    - Inline guidance explaining composition groups and fungibility exceptions
  - Tip message for bottled allocations that advanced constraints are optional
  - LiquidAllocationConstraint created in afterCreate hook for liquid allocations with specified data
- **Learnings for future iterations:**
  - Use `->hidden()` combined with `->collapsed()` and `->collapsible()` to control section visibility and state based on other form fields
  - For liquid-specific related models (LiquidAllocationConstraint), create them in afterCreate only when the allocation is liquid using `$allocation->isLiquid()` helper
  - Session storage pattern works well for multiple related model data: store in `mutateFormDataBeforeCreate()`, apply in `afterCreate()`
  - Use `liquid_constraint.field_name` dot notation pattern consistent with `constraint.field_name` for nested model fields
---

## 2026-02-03 - US-012
- What was implemented: Create Allocation wizard - Step 5 (Review & Create)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getReviewStep method, getWizardSubmitActions, createAsDraft, createAndActivate, updated afterCreate)
  - `app/Policies/AllocationPolicy.php` (new) - Authorization policy for Allocation model
  - `app/Providers/AppServiceProvider.php` (updated to register AllocationPolicy)
- **Features implemented:**
  - Step 5: Review & Create with check-badge icon
  - Read-only summary sections for: Bottle SKU, Source & Capacity, Commercial Constraints
  - Advanced Constraints section (shown only if composition_constraint_group or fungibility_exception is set)
  - Liquid Allocation Constraints section (shown only for liquid allocations)
  - Draft warning message: "Draft allocations cannot be consumed and do not issue vouchers"
  - Before You Create section with guidance on both creation options
  - Two submit actions via custom getWizardSubmitActions() returning Blade component:
    - "Create as Draft" (primary button) - creates allocation in Draft status
    - "Create and Activate" (success button, role-based) - creates and immediately activates
  - AllocationPolicy with `activate` permission for role-based button visibility using @can directive
  - AfterCreate hook calls AllocationService::activate() when shouldActivateAfterCreate is true
  - Filament Notification messages for both success paths and activation failure
- **Learnings for future iterations:**
  - Custom wizard submit buttons can be implemented by returning HtmlString from getWizardSubmitActions() with Blade::render()
  - Use Livewire wire:click="methodName" to call page methods from custom buttons
  - For role-based actions in wizards, use @can directive with policy
  - Policies for models in subdirectories (App\Models\Allocation\Allocation) need explicit registration in AppServiceProvider using Gate::policy()
  - Property $shouldActivateAfterCreate pattern works for tracking button-specific behavior across create() and afterCreate()
---

## 2026-02-03 - US-013
- What was implemented: Allocation Detail view with 6 tabs organized using Filament Infolist Tabs
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/ViewAllocation.php` (complete rewrite with tabs)
  - `app/Models/Allocation/Allocation.php` (added auditLogs() morphMany relationship)
- **Features implemented:**
  - Tab 1 - Overview: Status & Identity (allocation ID, UUID, status badges, source type, supply form, serialization), Bottle SKU info, Quantities (total, sold, remaining, available), Availability Window, Lineage Rule explanation
  - Tab 2 - Constraints: Commercial constraints display with Edit link (visible only in Draft), Advanced constraints section (composition group, fungibility exception), Liquid constraints section (for liquid allocations)
  - Tab 3 - Capacity & Consumption: Capacity overview with utilization percentage, Active reservations impact showing reserved vs available quantity, Placeholder for future consumption breakdown by sellable SKU/channel/time (pending Voucher implementation)
  - Tab 4 - Reservations: RepeatableEntry showing all temporary reservations with ID, quantity, context type, status, expires_at, and reference; Summary counts by status (total, active, expired, converted)
  - Tab 5 - Vouchers: Placeholder for future voucher list (pending US-015+ implementation)
  - Tab 6 - Audit: RepeatableEntry showing auditLogs with event badge, user, timestamp, and formatted changes
  - Header Actions: Activate (visible for Draft, role-based), Close (visible for Active/Exhausted, role-based), Edit, More (Delete/Restore)
- **Learnings for future iterations:**
  - Use `Tabs::make()->tabs([...])` with separate methods for each Tab for clean organization
  - Use `->persistTabInQueryString()` to preserve active tab in URL
  - Tab badges can show counts with `->badge(fn () => ...)` and `->badgeColor()`
  - Use `RepeatableEntry::make('relationshipName')` to display hasMany relationships in infolist
  - TextEntry `->getStateUsing()` allows computed values; use service calls for business logic
  - Sections support `->headerActions([...])` for inline action buttons
  - AuditLog polymorphic relationship uses `morphMany(\App\Models\AuditLog::class, 'auditable')`
  - Authorization on header actions: `->authorize('policyMethod', $record)`
---

## 2026-02-03 - US-014
- What was implemented: Allocation status transitions with audit logging and user-friendly validation
- Files changed:
  - `app/Services/Allocation/AllocationService.php` (enhanced with audit logging and transition methods)
- **Features implemented:**
  - `logStatusTransition()` - protected method to create AuditLog entries for status changes
  - `transitionTo()` - generic transition method with comprehensive error messages
  - `canTransitionTo()` - helper method to check if transition is valid
  - All status transitions (activate, close, markAsExhausted, auto-exhausted) now log audit entries
  - Audit entries include: event type (status_change), old_values (status, label), new_values (status, label), user_id, timestamp
  - Enhanced error messages explain allowed transitions and provide guidance
- **Learnings for future iterations:**
  - Use AuditLog::EVENT_STATUS_CHANGE constant for status transition events
  - Always capture $oldStatus BEFORE changing $allocation->status
  - Auth::id() returns current user ID for audit logging
  - Constraint editing protection is already handled by model boot events (AllocationConstraint and LiquidAllocationConstraint)
  - For comprehensive error messages, use allowedTransitions() to show valid options
---

## 2026-02-03 - US-015
- What was implemented: Voucher model as atomic customer entitlement for Module A
- Files changed:
  - `database/migrations/2026_02_03_290000_create_customers_table.php` (new) - placeholder for Module K
  - `database/migrations/2026_02_03_300000_create_vouchers_table.php` (new)
  - `app/Models/Customer/Customer.php` (new) - placeholder for Module K
  - `app/Models/Allocation/Voucher.php` (new)
  - `app/Models/Allocation/Allocation.php` (added vouchers() relationship)
- **Features implemented:**
  - Voucher model with all required fields: customer_id, allocation_id, wine_variant_id, format_id, sellable_sku_id (nullable), quantity (always 1), lifecycle_state, tradable, giftable, suspended, sale_reference, created_by
  - BelongsTo relationships: Customer, Allocation, WineVariant, Format, SellableSku
  - HasMany vouchers() relationship added to Allocation model
  - Quantity=1 invariant enforced in both creating and saving boot events
  - allocation_id immutability enforced in updating boot event (lineage protection)
  - Lifecycle state helper methods: isIssued(), isLocked(), isRedeemed(), isCancelled(), isTerminal()
  - Behavioral flag helpers: canBeTradedOrTransferred(), canBeGifted()
  - UI display helpers: getBottleSkuLabel(), getLifecycleStateLabel(), getLifecycleStateColor(), getLifecycleStateIcon()
  - AuditLog morphMany relationship for future audit trail
- **Learnings for future iterations:**
  - Voucher uses wine_variant_id + format_id as bottle SKU reference (no BottleSku model) - consistent with Allocation
  - Customer model created as placeholder in `app/Models/Customer/` - will be enhanced by Module K
  - Voucher lifecycle states are constants (enum will be added in US-016)
  - Immutability can be enforced via updating boot event with isDirty() check
  - Voucher only has created_by (no updated_by) since most fields are immutable or controlled by services
---

## 2026-02-03 - US-016
- What was implemented: VoucherLifecycleState enum for voucher lifecycle management
- Files changed:
  - `app/Enums/Allocation/VoucherLifecycleState.php` (new)
  - `app/Models/Allocation/Voucher.php` (updated to use enum)
- **Features implemented:**
  - Enum with 4 states: Issued, Locked, Redeemed, Cancelled
  - Terminal states: Redeemed, Cancelled (isTerminal() returns true)
  - Valid transitions: issued→locked, issued→cancelled, locked→redeemed, locked→issued (unlock)
  - Filament-compatible helpers: label(), color(), icon()
  - Transition helpers: allowedTransitions(), canTransitionTo()
  - State behavior helpers: isTerminal(), isActive(), allowsTrading(), allowsFlagModification()
  - description() method for UI state explanation
  - Voucher model updated: removed string constants, added enum cast, updated all helper methods to use enum
  - Added model methods: canTransitionTo(), getAllowedTransitions() for transition logic at model level
- **Learnings for future iterations:**
  - When converting string constants to enums, update: imports, casts, all comparison checks, and helper methods
  - Enum methods can delegate logic (e.g., model.isTerminal() → model.lifecycle_state.isTerminal())
  - Add allowsTrading() to VoucherLifecycleState since trading is only allowed in Issued state
  - description() method useful for UI tooltips and explanatory text
---

## 2026-02-03 - US-017
- What was implemented: CaseEntitlement model for grouping vouchers when a customer buys a fixed case
- Files changed:
  - `database/migrations/2026_02_03_310000_create_case_entitlements_table.php` (new)
  - `database/migrations/2026_02_03_320000_add_case_entitlement_id_to_vouchers_table.php` (new)
  - `app/Enums/Allocation/CaseEntitlementStatus.php` (new)
  - `app/Models/Allocation/CaseEntitlement.php` (new)
  - `app/Models/Allocation/Voucher.php` (added case_entitlement_id and relationship)
- **Features implemented:**
  - CaseEntitlement model with: customer_id, sellable_sku_id, status (enum), broken_at, broken_reason
  - CaseEntitlementStatus enum with Intact and Broken states
  - Enum helpers: label(), color(), icon(), canBeBroken(), isBroken(), isIntact()
  - CaseEntitlement relationships: belongsTo Customer, belongsTo SellableSku, hasMany Voucher
  - CaseEntitlement helpers: isIntact(), isBroken(), canBeBroken(), getVouchersCount(), checkIntegrity()
  - Voucher model: added case_entitlement_id to fillable, caseEntitlement() relationship
  - Voucher helpers: isPartOfCase(), isPartOfIntactCase()
- **Learnings for future iterations:**
  - CaseEntitlement does NOT use soft deletes (once created, it exists permanently for audit trail)
  - The break logic is NOT implemented yet in boot events - it will be triggered by CaseEntitlementService (US-020)
  - checkIntegrity() method can be used to verify case integrity before operations
  - Break reason values will be: 'transfer', 'trade', 'partial_redemption' (to be enforced by service)
---

## 2026-02-03 - US-018
- What was implemented: VoucherTransfer model for tracking transfers of vouchers between customers
- Files changed:
  - `database/migrations/2026_02_03_330000_create_voucher_transfers_table.php` (new)
  - `app/Enums/Allocation/VoucherTransferStatus.php` (new) - pending, accepted, cancelled, expired
  - `app/Models/Allocation/VoucherTransfer.php` (new)
  - `app/Models/Allocation/Voucher.php` (added voucherTransfers relationships)
- **Features implemented:**
  - VoucherTransfer model with: voucher_id, from_customer_id, to_customer_id, status, initiated_at, expires_at, accepted_at, cancelled_at
  - VoucherTransferStatus enum with 4 states and transition helpers (isPending, isAccepted, canBeCancelled, canBeAccepted, isTerminal)
  - BelongsTo relationships: voucher(), fromCustomer(), toCustomer()
  - Scopes: pending(), needsExpiration(), forVoucher(), fromCustomer(), toCustomer()
  - Status helpers: isPending(), isAccepted(), isTerminal(), hasExpired(), canBeCancelled(), canBeAccepted()
  - UI helpers: getStatusLabel(), getStatusColor(), getStatusIcon(), getStatusDescription()
  - Voucher model: added voucherTransfers(), pendingTransfers(), hasPendingTransfer(), getPendingTransfer()
- **Learnings for future iterations:**
  - Transfer does NOT create a new voucher - it only changes voucher.customer_id on acceptance
  - Transfer does NOT consume allocation - it's a customer-to-customer operation
  - VoucherTransfer does NOT use soft deletes (transfers are immutable once created)
  - Only one pending transfer per voucher at a time (enforced by unique index where status = 'pending')
  - The actual transfer logic (accept, cancel, expire) will be implemented in VoucherTransferService (US-021)
  - needsExpiration() scope can be used by a scheduled job to expire pending transfers
---

## 2026-02-03 - US-019
- What was implemented: VoucherService for centralizing voucher business logic
- Files changed:
  - `app/Services/Allocation/VoucherService.php` (new)
  - `app/Models/AuditLog.php` (added new event type constants)
- **Methods implemented:**
  - `issueVouchers(Allocation, Customer, SellableSku, saleReference, quantity)`: Creates vouchers and consumes allocation atomically using AllocationService
  - `lockForFulfillment(Voucher)`: issued → locked transition with validation
  - `unlock(Voucher)`: locked → issued transition with validation
  - `redeem(Voucher)`: locked → redeemed transition (terminal state)
  - `cancel(Voucher)`: issued → cancelled transition (terminal state)
  - `suspend(Voucher, reason)`: Sets suspended=true with optional reason
  - `reactivate(Voucher)`: Sets suspended=false (unsuspend)
  - `setTradable(Voucher, bool)`: Updates tradable flag with validation
  - `setGiftable(Voucher, bool)`: Updates giftable flag with validation
  - `transitionTo(Voucher, VoucherLifecycleState)`: Generic transition method
- **AuditLog event types added:**
  - EVENT_LIFECYCLE_CHANGE: For voucher lifecycle state transitions
  - EVENT_FLAG_CHANGE: For behavioral flag changes (tradable, giftable)
  - EVENT_VOUCHER_ISSUED: For voucher issuance
  - EVENT_VOUCHER_SUSPENDED: For voucher suspension
  - EVENT_VOUCHER_REACTIVATED: For voucher reactivation
- **Learnings for future iterations:**
  - VoucherService injects AllocationService for allocation consumption during issuance
  - Suspended vouchers block ALL operations (lifecycle transitions, flag modifications)
  - Tradable/giftable flags can only be modified on issued vouchers (not locked)
  - Cancel does NOT return quantity to allocation - it's a soft cancellation
  - All lifecycle transitions and flag changes are logged to AuditLog with old/new values
  - validateNotSuspended() helper centralizes suspension check for multiple methods
---

## 2026-02-03 - US-020
- What was implemented: CaseEntitlementService for centralizing case entitlement business logic
- Files changed:
  - `app/Services/Allocation/CaseEntitlementService.php` (new)
- **Methods implemented:**
  - `createFromVouchers(array|Collection vouchers, Customer, SellableSku)`: Creates CaseEntitlement and associates vouchers with comprehensive validation (same customer, not already in case, not terminal)
  - `breakEntitlement(CaseEntitlement, reason)`: Irreversible status transition to Broken, sets broken_at timestamp and broken_reason, logs audit event
  - `isIntact(CaseEntitlement)`: Verifies case status is intact AND all vouchers pass checkIntegrity (same holder, none redeemed)
  - `breakIfVoucherInCase(Voucher, reason)`: Helper for automatic case break when voucher operations occur
  - `getIntactCaseCountForCustomer(Customer)`: Utility for counting intact cases
  - `getCaseEntitlementsForCustomer(Customer)`: Utility for listing all case entitlements
- **Constants defined:**
  - REASON_TRANSFER: 'transfer' - for voucher transfers
  - REASON_TRADE: 'trade' - for external trading
  - REASON_PARTIAL_REDEMPTION: 'partial_redemption' - for redeeming individual vouchers from case
- **Learnings for future iterations:**
  - CaseEntitlementService should be called by VoucherService/VoucherTransferService via breakIfVoucherInCase() when operations would break case integrity
  - The actual automatic trigger integration (US-029) will connect VoucherService lifecycle transitions and VoucherTransferService acceptance to breakIfVoucherInCase()
  - Use Collection or array for voucher input, service handles both types
  - Break is completely irreversible - there's no restore/unbreak operation
  - Voucher model's id IS the UUID (due to HasUuid trait), no separate uuid column exists
---

## 2026-02-03 - US-021
- What was implemented: VoucherTransferService for managing voucher transfers (gifting) between customers
- Files changed:
  - `app/Services/Allocation/VoucherTransferService.php` (new)
  - `app/Jobs/Allocation/ExpireTransfersJob.php` (new)
  - `app/Models/AuditLog.php` (added transfer event constants)
  - `routes/console.php` (registered ExpireTransfersJob scheduled job)
- **Methods implemented:**
  - `initiateTransfer(Voucher, Customer, Carbon)`: Creates pending transfer with comprehensive validation (voucher must be issued, not suspended, not have pending transfer, must be giftable)
  - `acceptTransfer(VoucherTransfer)`: Updates voucher.customer_id to recipient, breaks CaseEntitlement if voucher is part of one, validates voucher not locked/suspended/terminal
  - `cancelTransfer(VoucherTransfer)`: Status → cancelled with audit logging
  - `expireTransfer(VoucherTransfer)`: Expires a single transfer
  - `expireTransfers()`: Batch method for scheduled job, returns count of expired transfers
  - `getPendingTransfer(Voucher)`, `hasPendingTransfer(Voucher)`: Helper methods
- **AuditLog events added:**
  - EVENT_TRANSFER_INITIATED, EVENT_TRANSFER_ACCEPTED, EVENT_TRANSFER_CANCELLED, EVENT_TRANSFER_EXPIRED
- **Learnings for future iterations:**
  - VoucherTransferService injects CaseEntitlementService for automatic case breaking on transfer acceptance
  - Transfer validation checks: issued state, not suspended, not locked, no pending transfer, giftable flag
  - acceptTransfer uses DB::transaction() for atomic update of voucher.customer_id + transfer status
  - Audit logs are created on BOTH the Voucher and VoucherTransfer models for complete audit trail
  - ExpireTransfersJob follows same pattern as ExpireReservationsJob, scheduled every minute
---

## 2026-02-03 - US-022
- What was implemented: VoucherResource in Filament for voucher list as entry point for customer entitlements
- Files changed:
  - `app/Filament/Resources/Allocation/VoucherResource.php` (new)
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ListVouchers.php` (new)
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ViewVoucher.php` (new - placeholder for US-023)
- **Features implemented:**
  - Navigation group 'Vouchers' with ticket icon, navigation sort 1
  - All required columns: id (copyable), customer (with link to customer view), bottle_sku (computed), sellable_sku, allocation_id (with link to allocation view), lifecycle_state (badge), flags (combined badge), created_at
  - Filters: lifecycle_state (multi-select, default excludes Redeemed/Cancelled), allocation (select with search), customer (select with search), suspended (ternary filter), trashed
  - Search: voucher_id, customer name/email, wine name/producer via custom query callbacks
  - NO Create action - canCreate() returns false and ListVouchers has empty getHeaderActions()
  - Eager loading via modifyQueryUsing for customer, wineVariant.wineMaster, format, sellableSku, allocation
- **Learnings for future iterations:**
  - Use `canCreate(): bool` returning false to disable create functionality in Filament resource
  - TernaryFilter is good for boolean fields with "all/true/false" options
  - Combined flags badge uses state() callback with manual formatting and separator
  - Customer link uses route() helper to link to customer resource view page
---

## 2026-02-03 - US-023
- What was implemented: Voucher Detail view with 6 sections for comprehensive voucher information display
- Files changed:
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ViewVoucher.php` (complete implementation)
- **Features implemented:**
  - Header section with prominent lifecycle state banner (voucher ID, current holder with link, lifecycle state badge with color-coded left border)
  - Section 1 - What Was Sold: sellable SKU, bottle SKU, quantity (always 1), sale reference, case entitlement subsection with status (shows case broken info if applicable)
  - Section 2 - Allocation Lineage: allocation ID (with link), source type, supply form, serialization required, constraints snapshot (collapsible), prominent "Lineage can never be modified" warning
  - Section 3 - Lifecycle State: current state badge with description, allowed transitions, terminal state indicator, visual transition diagram (collapsible HTML diagram showing state flows)
  - Section 4 - Behavioral Flags: tradable, giftable, suspended flags with Yes/No badges and helper text, info message about flag modification rules based on voucher state
  - Section 5 - Transfer Context: pending transfers list with recipient, status, dates; transfer history (collapsed) with from/to/status/dates; info message about transfers not consuming allocation
  - Section 6 - Event History: RepeatableEntry of audit logs with event badge, user, timestamp, formatted changes; audit information (collapsed)
  - Custom title and subheading showing voucher ID and bottle SKU with lifecycle state
- **Learnings for future iterations:**
  - Filament Infolist Sections do NOT support `badge()` method (unlike Tabs) - use TextEntry inside the section for badge display
  - Use `extraAttributes` on Section to add custom CSS classes (e.g., border-left color based on state)
  - For complex displays like audit logs, use `getStateUsing()` with formatted HTML and `->html()` modifier
  - SellableSku uses `sku_code` field, not `name` - check model properties before referencing
  - Use `getSubheading()` on ViewRecord for secondary title information
  - Visual state diagrams can be embedded as HTML using TextEntry with `->html()` modifier
---

## 2026-02-03 - US-024
- What was implemented: Voucher behavioral flags management with toggle actions and confirmation dialogs
- Files changed:
  - `app/Policies/VoucherPolicy.php` (new) - Authorization policy for Voucher model with flag management permissions
  - `app/Providers/AppServiceProvider.php` (updated to register VoucherPolicy)
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ViewVoucher.php` (added header actions for flag toggles)
- **Features implemented:**
  - Toggle Tradable action: Enable/Disable trading with confirmation dialog
  - Toggle Giftable action: Enable/Disable gifting with confirmation dialog
  - Suspend action: Suspend voucher to block all operations, with confirmation dialog
  - Reactivate action: Unsuspend voucher to resume normal operations, with confirmation dialog
  - VoucherPolicy with permissions: manageFlags, setTradable, setGiftable, suspend, reactivate
  - All actions use VoucherService methods which include audit logging
  - Visibility rules:
    - Tradable/Giftable toggles: only visible when voucher is issued AND not suspended
    - Suspend: only visible when voucher is not suspended AND not terminal
    - Reactivate: only visible when voucher IS suspended AND not terminal
  - All actions require confirmation before execution
  - Error handling with user-friendly notifications for validation failures
- **Learnings for future iterations:**
  - Use `Action::make()` in `getHeaderActions()` for view page actions
  - Use `requiresConfirmation()` with `modalHeading()`, `modalDescription()`, `modalSubmitActionLabel()` for confirmation dialogs
  - Use `visible()` callback for conditional action visibility based on record state
  - Use `authorize()` method to tie action to policy permission
  - `app(VoucherService::class)` to resolve service from container inside action callbacks
  - `$this->refreshFormData([])` (with empty array or specific fields) refreshes the page data after action
---

## 2026-02-03 - US-025
- What was implemented: Voucher transfer UI for managing transfers from admin panel
- Files changed:
  - `app/Policies/VoucherPolicy.php` (added initiateTransfer and cancelTransfer permissions)
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ViewVoucher.php` (added Initiate Transfer and Cancel Transfer header actions)
- **Features implemented:**
  - Initiate Transfer action with form: recipient customer search select (excludes current holder), expiration date picker (min 1 day, default 2 weeks)
  - Form includes info message: "Transfers do not create new vouchers or consume allocation. They only change the voucher holder."
  - Cancel Transfer action with confirmation dialog showing recipient name
  - Both actions use VoucherTransferService methods (initiateTransfer, cancelTransfer) which include audit logging
  - Visibility rules:
    - Initiate Transfer: visible when voucher is issued, not suspended, not in pending transfer, and giftable
    - Cancel Transfer: visible when voucher has a pending transfer
  - Accept Transfer NOT available from admin (done by recipient in customer portal)
  - Error handling with user-friendly notifications for validation failures
- **Learnings for future iterations:**
  - Use `form([...])` method on Action to add a form modal before execution
  - Use `Select::make()->searchable()->getSearchResultsUsing()` for customer search with custom query
  - Use `DatePicker::make()->minDate(now()->addDay())->default()` for date validation
  - Use `Carbon::parse($data['expires_at'])->endOfDay()` to set expiration at end of day
  - Placeholder component in form modal useful for displaying info messages
  - Dynamic modal description can use closure: `->modalDescription(function () { ... })`
---

## 2026-02-03 - US-026
- What was implemented: CustomerResource with Vouchers tab for viewing customer's voucher portfolio
- Files changed:
  - `app/Filament/Resources/Customer/CustomerResource.php` (new) - Main resource with list, create, edit, view pages
  - `app/Filament/Resources/Customer/CustomerResource/Pages/ListCustomers.php` (new)
  - `app/Filament/Resources/Customer/CustomerResource/Pages/CreateCustomer.php` (new)
  - `app/Filament/Resources/Customer/CustomerResource/Pages/EditCustomer.php` (new)
  - `app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php` (new) - Detail view with Vouchers tab
- **Features implemented:**
  - CustomerResource in navigation group 'Customers' with user-group icon
  - Customer list with: id, name, email, status badge, vouchers count, created_at
  - Status filter (default: Active) and trashed filter
  - ViewCustomer page with 2 tabs:
    - Overview: Customer ID, name, email, status badge, dates
    - Vouchers: Summary stats (total, issued, locked, redeemed) + voucher list via RepeatableEntry
  - Voucher list shows: voucher_id (link to detail), bottle_sku, lifecycle_state badge, flags badge, allocation link, created_at
  - 'View All in Vouchers List' header action links to VoucherResource filtered by customer
  - Tab badge shows total voucher count
- **Learnings for future iterations:**
  - CustomerResource created from scratch (no existing resource) - Customer was a placeholder model
  - Use RepeatableEntry instead of HasTable interface in ViewRecord to avoid property conflicts
  - Tab badges: use `->badge($count > 0 ? (string) $count : null)` to show count only when positive
  - Use `VoucherResource::getUrl('index', ['tableFilters' => ...])` to link to filtered list
  - Header actions on Section: use `->headerActions([Action::make(...)])` for inline section buttons
---

## 2026-02-03 - US-027
- What was implemented: Allocation Vouchers tab (read-only) - replaced placeholder with full voucher list and summary
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/ViewAllocation.php` (updated getVouchersTab method)
- **Features implemented:**
  - Voucher Summary section with Grid(4) showing:
    - Total Issued (bold, large, primary color)
    - Issued count (success, ticket icon)
    - Locked count (warning, lock icon)
    - Redeemed count (info, check-badge icon)
    - Cancelled count (danger, x-circle icon)
  - Issued Vouchers section with RepeatableEntry showing:
    - Voucher ID (link to detail, copyable, primary color)
    - Customer name
    - Lifecycle state badge with color and icon from enum
    - Flags badge (Suspended, Tradable, Giftable)
    - Created at timestamp
  - 'View All in Vouchers List' header action linking to VoucherResource with allocation filter (visible when vouchers > 0)
  - Tab badge showing total voucher count with success color
  - Empty state message when no vouchers issued yet
  - Lineage Information section (collapsible) explaining voucher lineage rules
  - NO modification actions - tab is completely read-only
- **Learnings for future iterations:**
  - Use `VoucherResource::getUrl('index', ['tableFilters' => ['allocation' => ['allocation_id' => $record->id]]])` pattern for filtered list links
  - RepeatableEntry inside Tab works well for displaying hasMany relationships (vouchers from allocation)
  - Tab badge counts: check count > 0 before returning string, otherwise return null
  - For lifecycle state badges in RepeatableEntry, use `formatStateUsing(fn (Voucher $record)...)` pattern
---

## 2026-02-03 - US-028
- What was implemented: CaseEntitlementResource in Filament for viewing and managing case entitlements (read-focused)
- Files changed:
  - `app/Filament/Resources/Allocation/CaseEntitlementResource.php` (new)
  - `app/Filament/Resources/Allocation/CaseEntitlementResource/Pages/ListCaseEntitlements.php` (new)
  - `app/Filament/Resources/Allocation/CaseEntitlementResource/Pages/ViewCaseEntitlement.php` (new)
- **Features implemented:**
  - CaseEntitlementResource in navigation group 'Vouchers' with cube icon, navigation sort 2
  - List view with columns: entitlement_id (copyable), customer (link to customer detail), sellable_sku, status badge (intact/broken with color and icon from enum), vouchers_count (using withCount), created_at, broken_at (toggleable)
  - Filters: status (multi-select using CaseEntitlementStatus enum), customer (searchable select)
  - No create action - canCreate() returns false
  - Detail view with 5 sections:
    - Header: entitlement ID, customer info, status badge (with color-coded left border), created date
    - Case Details: sellable SKU, bottles count, integrity status badge, UUID
    - Vouchers in Case: summary counts (total, issued, locked, redeemed, cancelled) + RepeatableEntry showing each voucher with link to detail, bottle SKU, current holder, lifecycle state badge, flags badge, created at. 'View All in Vouchers List' header action
    - Break Information (shown only if broken): broken_at timestamp, broken_reason (formatted), irreversibility notice
    - Event History: audit logs with event badge, user, timestamp, formatted changes
  - No manual break actions - breaking happens automatically via CaseEntitlementService (US-029)
- **Learnings for future iterations:**
  - Use `->withCount('vouchers')` in modifyQueryUsing for efficient count columns
  - CaseEntitlement uses CaseEntitlementStatus enum with isIntact()/isBroken() helpers
  - checkIntegrity() method on model verifies all vouchers still belong to same customer and none redeemed
  - ViewRecord pages can use `->hidden()` and `->collapsed()` based on record state for conditional section display
  - For "View All" filtered links, may need to add custom filter to VoucherResource for case_entitlement_id
---

## 2026-02-03 - US-029
- What was implemented: Automatic case breaking rules when voucher operations occur
- Files changed:
  - `app/Services/Allocation/VoucherService.php` (added CaseEntitlementService injection and breakIfVoucherInCase call in redeem())
- **Features implemented:**
  - VoucherService now injects CaseEntitlementService for automatic case breaking
  - redeem() method calls breakIfVoucherInCase() with REASON_PARTIAL_REDEMPTION
  - Break triggers (already implemented or to be implemented):
    - Transfer: VoucherTransferService.acceptTransfer() with REASON_TRANSFER (already existed from US-021)
    - Partial Redemption: VoucherService.redeem() with REASON_PARTIAL_REDEMPTION (new in this story)
    - Trade: Will be triggered by US-032 external trading feature (future)
  - Break is irreversible: CaseEntitlementStatus.canBeBroken() returns false once status is Broken
  - Vouchers remain valid after case break (behave as loose bottles)
  - All break events logged via CaseEntitlementService.logCaseEvent() with EVENT_STATUS_CHANGE
- **Learnings for future iterations:**
  - Case breaking logic is centralized in CaseEntitlementService.breakIfVoucherInCase() - call this from any service that performs operations that would break case integrity
  - REASON_TRADE will need to be integrated in US-032 when external trading suspension is implemented
  - VoucherService needs both AllocationService and CaseEntitlementService injected for its operations
---

## 2026-02-03 - US-030
- What was implemented: Customer Case Entitlements view - section in Customer Detail to view case entitlements
- Files changed:
  - `app/Models/Customer/Customer.php` (added caseEntitlements() hasMany relationship)
  - `app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php` (added getCaseEntitlementsSection method)
- **Features implemented:**
  - caseEntitlements() relationship on Customer model for loading case entitlements
  - Case Entitlements section added to Vouchers tab in Customer Detail view
  - Summary with counts: Total Cases, Intact (success color), Broken (danger color)
  - Visual indicators: success green for Intact status, danger red for Broken status
  - RepeatableEntry list with: entitlement_id (link to detail, copyable), sellable_sku, status badge with color/icon, vouchers count
  - 'View All in Cases List' header action linking to CaseEntitlementResource filtered by customer
  - Section is collapsible, collapsed by default when customer has no case entitlements
  - Placeholder message when no case entitlements found
- **Learnings for future iterations:**
  - Use getCaseEntitlementsSection() pattern for reusable section components with pre-computed counts
  - Pass pre-computed counts to section method to avoid redundant queries
  - Section collapsible state can be controlled dynamically with `->collapsed($totalCaseEntitlements === 0)`
  - PHPStan reports nullsafe operator `?->` as unnecessary when Filament guarantees relationship loading - use `->` instead
---

## 2026-02-03 - US-031
- What was implemented: VoucherTransferResource in Filament for global transfer management
- Files changed:
  - `app/Filament/Resources/Allocation/VoucherTransferResource.php` (new)
  - `app/Filament/Resources/Allocation/VoucherTransferResource/Pages/ListVoucherTransfers.php` (new)
  - `app/Filament/Resources/Allocation/VoucherTransferResource/Pages/ViewVoucherTransfer.php` (new)
  - `app/Policies/VoucherTransferPolicy.php` (new)
  - `app/Providers/AppServiceProvider.php` (registered VoucherTransferPolicy)
- **Features implemented:**
  - VoucherTransferResource in navigation group 'Vouchers' with arrows-right-left icon, navigation sort 3
  - List view with columns: transfer_id (copyable), voucher_id (link to voucher detail, primary color), from_customer (link with email description), to_customer (link with email), status badge (color/icon from VoucherTransferStatus enum), initiated_at, expires_at (with visual expired indicator when pending and past), accepted_at (toggleable), cancelled_at (toggleable)
  - Filters: status (multi-select, default Pending), date_range (initiated_from/until via DatePicker), from_customer (searchable select), to_customer (searchable select), voucher (text input)
  - Cancel Transfer action in table (role-based via authorize('cancelTransfer'), visible only when canBeCancelled())
  - Detail view with: Status banner (color-coded border based on status), Voucher Information section (voucher ID link, bottle SKU, lifecycle state badge, allocation link), Transfer Participants section (from/to customer with names and emails), Timeline section (initiated_at, expires_at with expired indicator, accepted_at/cancelled_at when applicable), Event History section (collapsed, showing audit logs)
  - Header actions in detail view: Cancel Transfer (with confirmation dialog), View Voucher (link to voucher detail)
  - VoucherTransferPolicy with viewAny, view, cancelTransfer permissions
  - No create action - canCreate() returns false (transfers created from Voucher detail page)
- **Learnings for future iterations:**
  - Infolists don't have Placeholder component like Forms - use TextEntry with getStateUsing() and icon() for info messages instead
  - For color-coded section borders, use extraAttributes() with a function that casts $this->record to the correct type for PHPStan
  - VoucherTransfer model already has excellent helper methods: canBeCancelled(), isPending(), hasExpired(), getStatusLabel/Color/Icon/Description()
  - Use `->description()` on TextColumn to show secondary info like email below customer name
---

## 2026-02-03 - US-032
- What was implemented: External trading suspension for vouchers
- Files changed:
  - `database/migrations/2026_02_03_340000_add_external_trading_reference_to_vouchers_table.php` (new) - adds external_trading_reference field
  - `app/Models/Allocation/Voucher.php` (added external_trading_reference field and helper methods)
  - `app/Models/AuditLog.php` (added TRADING_SUSPENDED and TRADING_COMPLETED event constants)
  - `app/Services/Allocation/VoucherService.php` (added suspendForTrading and completeTrading methods)
  - `app/Filament/Resources/Allocation/VoucherResource.php` (updated flags column for trading display)
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ViewVoucher.php` (added External Trading section and updated suspension display)
- **Features implemented:**
  - external_trading_reference field (string nullable) on vouchers table
  - suspendForTrading(voucher, tradingReference): Suspends voucher with trading reference, validates tradable state, breaks case entitlement
  - completeTrading(voucher, tradingReference, newCustomer): Validates trading reference match, transfers to new customer, unsuspends, preserves lineage
  - UI shows 'Suspended for external trading' when suspended=true AND external_trading_reference is present
  - Voucher list shows 'Trading' badge (warning color) instead of 'Suspended' when trading
  - External Trading section in Transfer Context shows trading status and reference
  - reactivate() method also clears external_trading_reference for consistency
  - Case entitlement breaks automatically with REASON_TRADE when suspended for trading
- **Learnings for future iterations:**
  - External trading is distinct from manual suspension - always check isSuspendedForTrading() for specific messaging
  - suspendForTrading requires voucher to be issued, tradable, not already suspended, and no pending transfer
  - completeTrading validates trading reference matches before transferring - security measure against mismatched references
  - Breaking case on suspend_for_trading (not on complete) because the decision to trade breaks case integrity
  - Use getSuspensionReason() helper for UI display of suspension reason
---

## 2026-02-03 - US-033
- What was implemented: API endpoint for trading completion callback from external trading platforms
- Files changed:
  - `routes/api.php` (new) - API routes file with /api/vouchers/{voucher}/trading-complete endpoint
  - `bootstrap/app.php` (updated) - Added api.php route registration
  - `app/Http/Controllers/Api/VoucherController.php` (new) - API controller with tradingComplete method
  - `app/Http/Requests/Api/Voucher/TradingCompleteRequest.php` (new) - Form request validation
- **Features implemented:**
  - POST /api/vouchers/{voucher}/trading-complete endpoint
  - TradingCompleteRequest validation: new_customer_id (required, integer, exists:customers), trading_reference (required, string, max:255)
  - VoucherController.tradingComplete() method that:
    - Validates request payload via TradingCompleteRequest
    - Finds the new customer by ID
    - Calls VoucherService.completeTrading() which validates: voucher is suspended, has external_trading_reference, trading_reference matches, voucher not terminal
    - Returns JSON success response with voucher data (id, new_customer_id, lifecycle_state, suspended=false, external_trading_reference=null)
    - Returns 422 error response with validation_error for InvalidArgumentException
  - Event logged via AuditLog.EVENT_TRADING_COMPLETED with old/new customer_id
- **Learnings for future iterations:**
  - Laravel 11 uses bootstrap/app.php for route registration with `api:` parameter in withRouting()
  - Form requests in `app/Http/Requests/Api/{Module}/` directory structure
  - API controllers in `app/Http/Controllers/Api/` directory
  - Use `validated('field_name')` method on FormRequest to get validated single values
  - VoucherService.completeTrading() handles all business validation - controller just orchestrates
  - Return 422 status for business validation errors (not 400)
---
