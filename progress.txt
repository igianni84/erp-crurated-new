# Ralph Progress Log
Started: Wed Feb  4 14:00:43 CET 2026

## Codebase Patterns
- Use `$table->uuid('id')->primary()` for model primary keys with HasUuid trait
- Models use Auditable trait with created_by/updated_by foreign keys to users
- Enums follow pattern: value cases with label(), color(), icon() methods
- Inventory module: app/Models/Inventory/, app/Enums/Inventory/, app/Services/Inventory/
- Module B branch is based on ralph/module-a-allocations branch
- Services throw InvalidArgumentException for validation errors

---

## 2026-02-04 - US-B001
- **Implemented**: Location model as base for physical storage management
- **Files created**:
  - app/Enums/Inventory/LocationType.php (5 location types with label/color/icon methods)
  - app/Enums/Inventory/LocationStatus.php (3 statuses with operational methods)
  - app/Models/Inventory/Location.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100000_create_locations_table.php
- **Learnings for future iterations**:
  - Location model relationships to InboundBatch, SerializedBottle, InventoryCase were deferred as those models don't exist yet
  - The serialization_authorized flag is key for US-B022 (serialization location blocker)
  - LocationStatus.canReceiveInventory() and canDispatchInventory() will be used by movement validation
---

## 2026-02-04 - US-B002
- **Implemented**: 8 inventory-related enums for Module B
- **Files created**:
  - app/Enums/Inventory/InboundBatchStatus.php (pending_serialization, partially_serialized, fully_serialized, discrepancy)
  - app/Enums/Inventory/BottleState.php (stored, reserved_for_picking, shipped, consumed, destroyed, missing)
  - app/Enums/Inventory/CaseIntegrityStatus.php (intact, broken)
  - app/Enums/Inventory/MovementType.php (internal_transfer, consignment_placement, consignment_return, event_shipment, event_consumption)
  - app/Enums/Inventory/MovementTrigger.php (wms_event, erp_operator, system_automatic)
  - app/Enums/Inventory/OwnershipType.php (crurated_owned, in_custody, third_party_owned)
  - app/Enums/Inventory/ConsumptionReason.php (event_consumption, sampling, damage_writeoff)
  - app/Enums/Inventory/DiscrepancyResolution.php (shortage, overage, damage, other)
- **Learnings for future iterations**:
  - LocationType and LocationStatus were already created in US-B001
  - Each enum includes helper methods beyond label/color/icon (e.g., canStartSerialization(), isAvailableForFulfillment())
  - InboundBatchStatus.canStartSerialization() will be key for serialization flow (US-B020-B023)
  - BottleState.isAvailableForFulfillment() and isTerminal() will be used by inventory service
  - CaseIntegrityStatus.canHandleAsUnit() will prevent operations on broken cases
  - OwnershipType.canConsumeForEvents() enforces only crurated_owned items can be consumed
---

## 2026-02-04 - US-B003
- **Implemented**: InboundBatch model as physical receipt record bridging procurement to serialized inventory
- **Files created**:
  - app/Models/Inventory/InboundBatch.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100001_create_inbound_batches_table.php
- **Relationships**:
  - belongsTo Location (receiving_location_id) - where batch is received
  - belongsTo Allocation (allocation_id) - preserves allocation lineage
  - morphTo productReference - polymorphic reference to wine product
- **Key fields**:
  - source_type (producer/supplier/transfer)
  - quantity_expected vs quantity_received for discrepancy tracking
  - serialization_status (uses InboundBatchStatus enum)
  - ownership_type (uses OwnershipType enum)
- **Learnings for future iterations**:
  - InboundBatch.allocation_id is the source of allocation lineage for all SerializedBottles created from it
  - getRemainingUnserializedAttribute() will need to count SerializedBottles when that model exists
  - canStartSerialization() checks both status and location.canSerialize()
  - hasDiscrepancy() compares expected vs received quantities
  - procurement_intent_id FK is nullable since ProcurementIntent model doesn't exist yet (Module D)
---

## 2026-02-04 - US-B004
- **Implemented**: SerializedBottle model as first-class object with unique identity
- **Files created**:
  - app/Models/Inventory/SerializedBottle.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100002_create_serialized_bottles_table.php
- **Files modified**:
  - app/Models/Inventory/InboundBatch.php (added serializedBottles relationship, updated getRemainingUnserializedAttribute)
  - app/Models/Inventory/Location.php (added serializedBottles and inboundBatches relationships)
- **Relationships**:
  - belongsTo WineVariant (wine_variant_id)
  - belongsTo Format (format_id)
  - belongsTo Allocation (allocation_id) - IMMUTABLE
  - belongsTo InboundBatch (inbound_batch_id)
  - belongsTo Location (current_location_id)
  - belongsTo InventoryCase (case_id) - nullable, model created in US-B005
- **Key immutability enforcement**:
  - serial_number: unique, cannot be changed after creation (DB constraint + model boot guard)
  - allocation_id: cannot be changed after creation (model boot guard)
  - Immutable fields throw InvalidArgumentException on modification attempt
- **Learnings for future iterations**:
  - InventoryCase model doesn't exist yet (US-B005), used @phpstan-ignore for case() relationship
  - Foreign key to cases table will be added when cases migration is created
  - InboundBatch.getRemainingUnserializedAttribute() now correctly counts serialized bottles
  - SerializedBottle.canConsumeForEvents() checks ownership_type.canConsumeForEvents() AND isStored()
  - All state-checking helper methods (isStored, isShipped, etc.) delegate to BottleState enum
---

## 2026-02-04 - US-B005
- **Implemented**: InventoryCase model as physical container for bottles
- **Files created**:
  - app/Models/Inventory/InventoryCase.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100003_create_cases_table.php
- **Files modified**:
  - app/Models/Inventory/SerializedBottle.php (updated case() relationship to use InventoryCase class)
  - app/Models/Inventory/Location.php (added cases() relationship)
  - app/Models/Inventory/InboundBatch.php (added cases() relationship)
- **Relationships**:
  - belongsTo CaseConfiguration (case_configuration_id)
  - belongsTo Allocation (allocation_id) - allocation lineage
  - belongsTo InboundBatch (inbound_batch_id) - nullable
  - belongsTo Location (current_location_id)
  - hasMany SerializedBottle (via case_id FK)
- **Key integrity enforcement**:
  - integrity_status: BROKEN cannot revert to INTACT (model boot guard throws InvalidArgumentException)
  - Breaking is irreversible per US-B052
- **Learnings for future iterations**:
  - Model named InventoryCase (not Case) to avoid PHP reserved keyword
  - Table is named 'cases' while model is InventoryCase
  - FK from serialized_bottles.case_id to cases.id added in this migration
  - canBreak() checks is_breakable AND isIntact() for Break Case action (US-B032)
  - bottle_count accessor counts related serializedBottles
---

## 2026-02-04 - US-B006
- **Implemented**: InventoryMovement model as immutable record of physical inventory events
- **Files created**:
  - app/Models/Inventory/InventoryMovement.php (HasUuid only, NO Auditable, NO SoftDeletes)
  - database/migrations/2026_02_04_100004_create_inventory_movements_table.php
- **Relationships**:
  - belongsTo Location (source_location_id) - nullable
  - belongsTo Location (destination_location_id) - nullable
  - belongsTo User (executed_by) - nullable
  - hasMany MovementItem (inventory_movement_id) - model created in US-B007
- **Key immutability enforcement**:
  - NO soft deletes - movements are never deleted
  - Model boot guard throws InvalidArgumentException on update attempt
  - Model boot guard throws InvalidArgumentException on delete attempt
  - Movements are append-only (insert only)
- **WMS deduplication**:
  - wms_event_id is unique nullable for deduplication
- **Learnings for future iterations**:
  - InventoryMovement does NOT use Auditable trait (movements ARE the audit log)
  - MovementItem model doesn't exist yet (US-B007), used @phpstan-ignore for relationship
  - MovementType and MovementTrigger enums already exist from US-B002
  - Helper methods delegate to enums (isWmsTriggered, isTransfer, isConsumption)
  - items_count accessor counts related movementItems
---

## 2026-02-04 - US-B007
- **Implemented**: MovementItem model as detail of items involved in inventory movements
- **Files created**:
  - app/Models/Inventory/MovementItem.php (NO Auditable, NO SoftDeletes, NO HasUuid)
  - database/migrations/2026_02_04_100005_create_movement_items_table.php
- **Files modified**:
  - app/Models/Inventory/InventoryMovement.php (removed @phpstan-ignore, fixed relationship return type)
- **Relationships**:
  - belongsTo InventoryMovement (inventory_movement_id) - required
  - belongsTo SerializedBottle (serialized_bottle_id) - nullable
  - belongsTo InventoryCase (case_id) - nullable
- **Key immutability enforcement**:
  - NO soft deletes - items are never deleted
  - Model boot guard throws InvalidArgumentException on update attempt
  - Model boot guard throws InvalidArgumentException on delete attempt
  - Items are append-only (insert only)
- **Validation**:
  - Creating hook validates at least one of serialized_bottle_id or case_id is set
- **Learnings for future iterations**:
  - MovementItem uses standard auto-incrementing id (not UUID) since it's not a standalone entity
  - MovementItem does NOT use Auditable (parent InventoryMovement is the audit record)
  - Helper methods hasBottle() and hasCase() for quick type checking
  - Uses cascadeOnDelete on inventory_movement_id FK (if parent is somehow deleted, items go too)
  - Uses nullOnDelete on serialized_bottle_id and case_id (item stays, reference becomes null)
---

## 2026-02-04 - US-B008
- **Implemented**: InventoryException model for recording inventory exceptions and audit trail
- **Files created**:
  - app/Models/Inventory/InventoryException.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100006_create_inventory_exceptions_table.php
- **Relationships**:
  - belongsTo SerializedBottle (serialized_bottle_id) - nullable
  - belongsTo InventoryCase (case_id) - nullable
  - belongsTo InboundBatch (inbound_batch_id) - nullable
  - belongsTo User (created_by) - required, the creator
  - belongsTo User (resolved_by) - nullable, the resolver
- **Key fields**:
  - exception_type: string (e.g., 'shortage', 'overage', 'damage', 'committed_consumption_override')
  - reason: required text explaining the exception
  - resolution: nullable text filled when resolved
  - resolved_at: timestamp for when exception was resolved
- **Helper methods**:
  - isResolved(), isPending() for checking resolution status
  - hasBottle(), hasCase(), hasInboundBatch() for checking related entities
- **Learnings for future iterations**:
  - InventoryException is used by US-B047 (Committed inventory consumption override) to flag exceptions for finance & ops review
  - The exception_type field is a string (not enum) for flexibility in exception types
  - Both creator and resolver relationships point to User model
  - Uses Auditable trait for created_by/updated_by audit trail
---

## 2026-02-04 - US-B009
- **Implemented**: InventoryService for centralized inventory logic
- **Files created**:
  - app/Services/Inventory/InventoryService.php
- **Methods implemented**:
  - getCommittedQuantity(Allocation): count unredeemed vouchers (Issued + Locked states)
  - getFreeQuantity(Allocation): physical bottles (stored state) - committed quantity
  - canConsume(SerializedBottle): checks if bottle can be consumed for events
  - getBottlesAtLocation(Location): returns stored bottles at a location
  - getBottlesByAllocationLineage(Allocation): returns all bottles for an allocation
- **Key logic**:
  - Committed = Vouchers in Issued or Locked lifecycle_state (NOT redeemed/cancelled)
  - Physical bottles = SerializedBottles in 'stored' state
  - canConsume checks: stored state, ownership_type.canConsumeForEvents(), free quantity > 0
- **Learnings for future iterations**:
  - Services go in app/Services/Inventory/ directory for inventory module
  - VoucherLifecycleState.Issued and .Locked are the unredeemed states
  - BottleState.Stored is the only state considered for physical availability
  - Bottle-to-voucher binding doesn't exist yet, so canConsume checks at allocation level
---
