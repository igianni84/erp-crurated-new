# Ralph Progress Log
Started: Wed Feb  4 10:35:15 CET 2026

## Codebase Patterns
- UUID primary keys: Use `$table->uuid('id')->primary()` in migrations and `HasUuid` trait in models
- FK to users: Use `$table->foreignId()` (integer) NOT `foreignUuid()` since users table uses integer IDs
- Morphic relationships: Use explicit key names `morphTo('product_reference')` with TWO migration columns: `_type` (string) and `_id` (uuid)
- Soft deletes: Always include `$table->softDeletes()` in migrations and `use SoftDeletes;` trait in models
- Audit fields: Include `created_by`, `updated_by` FKs and use `Auditable` trait
- Enums: String-backed PHP 8.1+ enums in `app/Enums/{Module}/` with `label()`, `color()`, `icon()` methods
- Models: Organized by module in `app/Models/{Module}/`
- Invariant enforcement: Use `boot()` method with `static::saving()` callback
- Filament resources: Organized by module in `app/Filament/Resources/{Module}/`, use navigation groups, Pages subdirectory for List/View/Create pages

---

## 2026-02-04 - US-001
- What was implemented:
  - Migration `2026_02_04_400001_create_procurement_intents_table.php` with all required fields
  - ProcurementIntent model with morphic relationship to SellableSku/LiquidProduct
  - Three enums: ProcurementTriggerType, SourcingModel, ProcurementIntentStatus
  - Quantity > 0 invariant enforced in boot() method
  - Soft deletes enabled
- Files changed:
  - database/migrations/2026_02_04_400001_create_procurement_intents_table.php (new)
  - app/Models/Procurement/ProcurementIntent.php (new)
  - app/Enums/Procurement/ProcurementTriggerType.php (new)
  - app/Enums/Procurement/SourcingModel.php (new)
  - app/Enums/Procurement/ProcurementIntentStatus.php (new)
- **Learnings for future iterations:**
  - BottleSku in PRD maps to SellableSku model in codebase
  - Morphic relationships need `instanceof` checks before accessing type-specific properties (PHPStan requirement)
  - Use `product_reference_type = 'sellable_skus'` or `'liquid_products'` for the morphic type column
---

## 2026-02-04 - US-002
- What was implemented:
  - Six new enums for Procurement module (3 already existed from US-001)
  - PurchaseOrderStatus: draft, sent, confirmed, closed
  - BottlingPreferenceStatus: pending, partial, complete, defaulted
  - BottlingInstructionStatus: draft, active, executed
  - InboundPackaging: cases, loose, mixed
  - OwnershipFlag: owned, in_custody, pending
  - InboundStatus: recorded, routed, completed
  - All enums follow established pattern with label(), color(), icon() methods
  - Status enums include allowedTransitions() and canTransitionTo() helpers
- Files changed:
  - app/Enums/Procurement/PurchaseOrderStatus.php (new)
  - app/Enums/Procurement/BottlingPreferenceStatus.php (new)
  - app/Enums/Procurement/BottlingInstructionStatus.php (new)
  - app/Enums/Procurement/InboundPackaging.php (new)
  - app/Enums/Procurement/OwnershipFlag.php (new)
  - app/Enums/Procurement/InboundStatus.php (new)
- **Learnings for future iterations:**
  - Enums with status transitions should include `allowedTransitions()` and `canTransitionTo()` methods
  - Include domain-specific helper methods (e.g., `OwnershipFlag::isClarified()`, `InboundStatus::allowsHandOff()`)
  - BottlingPreferenceStatus tracks customer preference collection and supports defaulting
---

## 2026-02-04 - US-003
- What was implemented:
  - Migration `2026_02_04_400003_create_purchase_orders_table.php` with all required fields
  - PurchaseOrder model with relationships to ProcurementIntent and Party (supplier)
  - Morphic relationship to product reference (SellableSku or LiquidProduct)
  - FK constraint: `procurement_intent_id` NOT NULL enforced at DB level
  - Invariant check in `boot()` method for early feedback
  - Added `purchaseOrders()` hasMany relationship to ProcurementIntent model
  - Soft deletes enabled
- Files changed:
  - database/migrations/2026_02_04_400003_create_purchase_orders_table.php (new)
  - app/Models/Procurement/PurchaseOrder.php (new)
  - app/Models/Procurement/ProcurementIntent.php (modified - added purchaseOrders relationship)
- **Learnings for future iterations:**
  - Use `foreignUuid()` for FK to other UUID-based tables (parties, procurement_intents)
  - Use `foreignId()` for FK to users (integer IDs)
  - PurchaseOrder requires ProcurementIntent - this invariant is enforced at both DB and model levels
---

## 2026-02-04 - US-004
- What was implemented:
  - Migration `2026_02_04_400004_create_bottling_instructions_table.php` with all required fields
  - BottlingInstruction model with relationships to ProcurementIntent and LiquidProduct
  - All required fields: bottle_equivalents, allowed_formats (JSON), allowed_case_configurations (JSON), default_bottling_rule, bottling_deadline, preference_status, personalised_bottling_required, early_binding_required, delivery_location, status, defaults_applied_at
  - FK constraint: `procurement_intent_id` required (NOT NULL enforced at DB level)
  - FK constraint: `liquid_product_id` required
  - Invariant check in `boot()` method for bottling_deadline required
  - Added `bottlingInstructions()` hasMany relationship to ProcurementIntent model
  - Soft deletes enabled
- Files changed:
  - database/migrations/2026_02_04_400004_create_bottling_instructions_table.php (new)
  - app/Models/Procurement/BottlingInstruction.php (new)
  - app/Models/Procurement/ProcurementIntent.php (modified - added bottlingInstructions relationship)
- **Learnings for future iterations:**
  - JSON fields use `$table->json()` in migration and `'array'` cast in model
  - For required date fields, check raw attributes in boot() to avoid PHPStan issues with Carbon casting
  - BottlingInstruction uses BottlingInstructionStatus for lifecycle and BottlingPreferenceStatus for preference collection tracking
  - Deadline urgency helper methods useful for UI display (getDeadlineUrgency, getDaysUntilDeadline)
---

## 2026-02-04 - US-005
- What was implemented:
  - Migration `2026_02_04_400005_create_inbounds_table.php` with all required fields
  - Inbound model with relationships to ProcurementIntent (optional) and PurchaseOrder (optional)
  - Morphic relationship to product reference (SellableSku or LiquidProduct)
  - All required fields: warehouse, quantity, packaging, ownership_flag, received_date, condition_notes, serialization_required, serialization_location_authorized, serialization_routing_rule, status, handed_to_module_b, handed_to_module_b_at
  - FK constraints: both procurement_intent_id and purchase_order_id are nullable (inbound can exist without intent but is flagged)
  - Ownership flag defaults to 'pending' - explicit that Inbound does NOT imply ownership
  - Added `inbounds()` hasMany relationship to ProcurementIntent and PurchaseOrder models
  - Soft deletes enabled
- Files changed:
  - database/migrations/2026_02_04_400005_create_inbounds_table.php (new)
  - app/Models/Procurement/Inbound.php (new)
  - app/Models/Procurement/ProcurementIntent.php (modified - added inbounds relationship)
  - app/Models/Procurement/PurchaseOrder.php (modified - added inbounds relationship)
- **Learnings for future iterations:**
  - Inbound is a "physical fact" entity - it records that goods arrived, NOT that we own them
  - Use nullable FKs when the relationship is optional but should still be flagged as "unlinked"
  - Helper methods like `isLinked()`, `isUnlinked()`, `hasOwnershipClarity()` are useful for business rule enforcement
  - The `canHandOffToModuleB()` method consolidates multiple preconditions (status, ownership clarity, not already handed off)
---

## 2026-02-04 - US-006
- What was implemented:
  - Migration `2026_02_04_400006_create_producer_supplier_configs_table.php` with all required fields
  - ProducerSupplierConfig model with one-to-one relationship to Party
  - All required fields: party_id (unique FK), default_bottling_deadline_days (int nullable), allowed_formats (JSON nullable), serialization_constraints (JSON nullable), notes (text nullable)
  - Unique constraint on party_id enforces one-to-one relationship
  - Added `supplierConfig()` hasOne relationship to Party model
  - Added `hasSupplierConfig()` helper method to Party model
  - Soft deletes enabled
- Files changed:
  - database/migrations/2026_02_04_400006_create_producer_supplier_configs_table.php (new)
  - app/Models/Procurement/ProducerSupplierConfig.php (new)
  - app/Models/Customer/Party.php (modified - added supplierConfig relationship)
- **Learnings for future iterations:**
  - One-to-one relationships use `$table->foreignUuid()->unique()` in migration
  - Optional one-to-one configs don't need invariants - they're simply created when needed
  - Helper methods for checking constraint satisfaction (isFormatAllowed, isSerializationLocationAuthorized) are useful for service layer
  - JSON fields with specific structures should document expected format in docblock
---

## 2026-02-04 - US-007
- What was implemented:
  - ProcurementIntentService class in app/Services/Procurement/
  - createFromVoucherSale(Voucher $voucher): Creates draft intent from voucher with voucher_driven trigger type
  - createFromAllocation(Allocation $allocation, int $quantity): Creates draft intent from allocation with allocation_driven trigger type
  - createManual(array $data): Creates draft intent manually with strategic trigger type
  - approve(ProcurementIntent $intent): Transitions draft → approved with approval timestamp and user
  - markExecuted(ProcurementIntent $intent): Transitions approved → executed
  - close(ProcurementIntent $intent): Transitions executed → closed with linked objects validation
  - canClose(ProcurementIntent $intent): Returns array with can_close flag and list of pending items
  - inferSourcingModelFromAllocation(): Helper to map AllocationSourceType to SourcingModel
  - All methods use explicit exceptions for validation errors
  - Audit logging for creation and status transitions
- Files changed:
  - app/Services/Procurement/ProcurementIntentService.php (new)
- **Learnings for future iterations:**
  - Services follow AllocationService pattern: methods return the modified model, throw InvalidArgumentException for errors
  - Use `getAttribute()` for nullable FK fields to avoid PHPStan type issues
  - AllocationSourceType enum values: producer_allocation, owned_stock, passive_consignment, third_party_custody
  - Match on enum cases directly instead of ->value when PHPStan has full type info
  - canClose() returns a structured array for UI to show pending items before closure attempt
---

## 2026-02-04 - US-008
- What was implemented:
  - InboundService class in app/Services/Procurement/
  - record(array $data): Creates Inbound in status recorded with full validation
  - route(Inbound $inbound, string $location): Transitions recorded → routed, sets serialization_location_authorized
  - complete(Inbound $inbound): Transitions routed → completed, validates ownership clarity
  - handOffToModuleB(Inbound $inbound): Marks handed_to_module_b = true with timestamp, validates preconditions
  - validateOwnershipClarity(Inbound $inbound): Throws if ownership_flag == pending
  - validateSerializationRouting(Inbound $inbound): Validates location is set when serialization_required = true
  - updateOwnershipFlag(Inbound $inbound, OwnershipFlag $newFlag): Helper to update ownership with audit
  - All methods use explicit InvalidArgumentException for validation errors
  - Audit logging for creation, status transitions, hand-off, and ownership updates
- Files changed:
  - app/Services/Procurement/InboundService.php (new)
- **Learnings for future iterations:**
  - InboundService follows same pattern as ProcurementIntentService
  - Hand-off to Module B is a one-way operation - cannot be reversed
  - Ownership clarity is required before completing or handing off
  - Serialization routing validation is a placeholder for future ProducerSupplierConfig.serialization_constraints integration
  - AuditLog::EVENT_FLAG_CHANGE is appropriate for boolean flag changes (handed_to_module_b, ownership_flag)
---

## 2026-02-04 - US-009
- What was implemented:
  - ProcurementIntentResource in Filament under navigation group "Procurement"
  - List columns: intent_id, product (via getProductLabel()), quantity, trigger_type, sourcing_model, preferred_location, status, linked_objects_count (badge), awaiting_action (icon), updated_at
  - Filters: status (with closed hidden by default), trigger_type, sourcing_model, trashed
  - Search: intent_id searchable directly, product searchable via complex multi-table query (sellable_skus, liquid_products, wine_masters)
  - Closed intents hidden by default via status filter defaulting to [draft, approved, executed]
  - Visual indicator (warning icon) for intents without linked objects that need action
  - ListProcurementIntents page with Create action
  - ViewProcurementIntent page (placeholder for US-014 detail tabs)
- Files changed:
  - app/Filament/Resources/Procurement/ProcurementIntentResource.php (new)
  - app/Filament/Resources/Procurement/ProcurementIntentResource/Pages/ListProcurementIntents.php (new)
  - app/Filament/Resources/Procurement/ProcurementIntentResource/Pages/ViewProcurementIntent.php (new)
- **Learnings for future iterations:**
  - Filament resources in this codebase use navigation groups (PIM, Customers, Vouchers, Procurement, etc.)
  - Use `withCount()` in modifyQueryUsing to efficiently count related records for badges
  - Complex morphic search requires raw SQL with `whereExists()` for multiple related tables
  - Status filters with multiple() and default() can hide terminal states by default
  - Visual indicators for "needs attention" use IconColumn with boolean state and custom trueIcon/falseIcon
---

## 2026-02-04 - US-010
- What was implemented:
  - CreateProcurementIntent wizard page with 4 steps (Product, Source & Model, Delivery, Review)
  - Step 1 (Product): Radio selection for product type (Bottle SKU vs Liquid Product)
  - Bottle SKU selection: Wine (searchable autocomplete) + Vintage (dependent select) + Format (dependent select)
  - Liquid Product selection: Wine (searchable autocomplete) + Vintage (dependent select)
  - Product preview showing selected product label
  - Existing allocations count display (queries Allocation table by wine_variant_id + format_id)
  - Informational message about Procurement Intent purpose
  - Warning when no matching SellableSku or LiquidProduct exists (auto-created on save)
  - Steps 2-4 (Source & Model, Delivery, Review) implemented ahead for complete wizard flow
  - mutateFormDataBeforeCreate() handles product reference resolution and auto-creates missing SKUs
- Files changed:
  - app/Filament/Resources/Procurement/ProcurementIntentResource/Pages/CreateProcurementIntent.php (new)
  - app/Filament/Resources/Procurement/ProcurementIntentResource.php (modified - registered create route)
- **Learnings for future iterations:**
  - Filament wizards use `CreateRecord\Concerns\HasWizard` trait
  - Live fields with `afterStateUpdated()` can cascade state resets when parent changes
  - Use `Get $get` for reading form state and `Set $set` for updating it
  - Hidden fields can store intermediate state (sellable_sku_id, liquid_product_id) for use in mutateFormDataBeforeCreate
  - When auto-creating SellableSku, need to provide a default CaseConfiguration
  - HtmlString allows rich HTML content in Placeholder components
---

## 2026-02-04 - US-011
- What was implemented:
  - Step 2 (Source & Model) was already implemented in US-010 iteration
  - Verified all acceptance criteria are met:
    - trigger_type, sourcing_model, quantity fields present
    - Trigger type guidance with dynamic explanations (voucher_driven, allocation_driven, strategic, contractual)
    - Sourcing model guidance with dynamic explanations (purchase, passive_consignment, third_party_custody)
    - Inline explanation updates dynamically based on selection
    - Quantity validation with minValue(1)
  - Typecheck and lint pass for all Procurement module files
- Files changed:
  - No new files (implementation was done ahead in US-010)
  - prd.json (marked US-011 as passes: true)
- **Learnings for future iterations:**
  - When implementing wizards, implementing all steps together provides better UX for testing
  - US-010 implemented ahead to provide complete wizard flow
  - Enum-based selects with Placeholder guidance provide excellent UX for domain-specific options
---

## 2026-02-04 - US-012
- What was implemented:
  - Step 3 (Delivery) was already implemented in US-010 iteration
  - Verified all acceptance criteria are met:
    - preferred_inbound_location (select) with authorized warehouse options
    - rationale (textarea) with "optional but recommended" helper text
    - Location options: main_warehouse, secondary_warehouse, bonded_warehouse, third_party_storage
    - Serialization constraints preview via location_preview placeholder
  - Typecheck and lint pass for all Procurement module files
- Files changed:
  - No new files (implementation was done ahead in US-010)
  - prd.json (marked US-012 as passes: true)
- **Learnings for future iterations:**
  - All 4 wizard steps (Product, Source & Model, Delivery, Review) were implemented together in US-010
  - Location-based serialization constraints are currently hardcoded - future enhancement could pull from ProducerSupplierConfig
  - Browser verification should be done manually as dev-browser skill is not available
---

## 2026-02-04 - US-013
- What was implemented:
  - Step 4 (Review) was already implemented in US-010 iteration
  - Fixed PHPStan type safety issues in CreateProcurementIntent.php:
    - Used `is_scalar()` checks before casting mixed values to string
    - Added PHPDoc type annotations for Eloquent find() results
    - Fixed all `Cannot cast mixed to string` errors
  - Verified all acceptance criteria are met:
    - Read-only summary of all data (Product, Source & Model, Delivery sections)
    - Warning shown when no existing allocations found
    - Intent created in status draft by default
    - Message "Draft intents require approval before execution" displayed
    - "Create as Draft" CTA button present
  - Typecheck and lint pass for all Procurement module files
- Files changed:
  - app/Filament/Resources/Procurement/ProcurementIntentResource/Pages/CreateProcurementIntent.php (modified - type safety fixes)
  - prd.json (marked US-013 as passes: true)
- **Learnings for future iterations:**
  - Use `is_scalar($value)` before `(string) $value` when getAttribute() returns mixed
  - Add PHPDoc `@var Type|null` annotations before Eloquent `find()` calls to help PHPStan
  - Filament wizard form state values from `$get()` are always mixed type - type check before use
---

## 2026-02-04 - US-014
- What was implemented:
  - ViewProcurementIntent page with 4 tabbed infolist sections
  - Tab 1 (Summary): status & identity, product info, demand source with trigger type explanations, sourcing model with explanations, delivery preferences, approval information
  - Tab 2 (Downstream Execution): linked Purchase Orders list with RepeatableEntry, linked Bottling Instructions list, linked Inbound batches list, execution summary with closure readiness indicator
  - Tab 3 (Allocation & Voucher Context): source context explanation based on trigger type, allocation/voucher info extracted from rationale, Module A integration notes
  - Tab 4 (Audit): immutable timeline with filter actions for event type and date range, formatted audit log entries with color-coded badges
  - Header actions: Approve (draft→approved), Mark Executed (approved→executed), Close (executed→closed with validation), Create Linked Object dropdown (Create PO, Create Bottling Instruction, Link Inbound)
  - Used ProcurementIntentService.canClose() for closure validation before showing close action
- Files changed:
  - app/Filament/Resources/Procurement/ProcurementIntentResource/Pages/ViewProcurementIntent.php (completely rewritten with 925 new lines)
  - prd.json (marked US-014 as passes: true)
- **Learnings for future iterations:**
  - Filament Infolist Tabs pattern: use `Tabs::make()->tabs([])` with `Tab::make()` for each tab, extract to helper methods for readability
  - Use `RepeatableEntry::make()` for displaying lists of related records with Grid layouts inside
  - Header actions can have `visible()`, `disabled()`, and `requiresConfirmation()` for conditional behavior
  - Section `headerActions` can include infolist Actions for contextual actions within sections
  - AuditLog created_at is always set (not nullable) so don't use nullsafe operator on Carbon methods
  - For closure validation, use service method that returns structured array with `can_close` and `pending_items`
---
