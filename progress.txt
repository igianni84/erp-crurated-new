# Ralph Progress Log
Started: Wed Feb  4 14:00:43 CET 2026

## Codebase Patterns
- Use `$table->uuid('id')->primary()` for model primary keys with HasUuid trait
- Models use Auditable trait with created_by/updated_by foreign keys to users
- Enums follow pattern: value cases with label(), color(), icon() methods
- Inventory module: app/Models/Inventory/, app/Enums/Inventory/, app/Services/Inventory/
- Module B branch is based on ralph/module-a-allocations branch
- Services throw InvalidArgumentException for validation errors

---

## 2026-02-04 - US-B001
- **Implemented**: Location model as base for physical storage management
- **Files created**:
  - app/Enums/Inventory/LocationType.php (5 location types with label/color/icon methods)
  - app/Enums/Inventory/LocationStatus.php (3 statuses with operational methods)
  - app/Models/Inventory/Location.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100000_create_locations_table.php
- **Learnings for future iterations**:
  - Location model relationships to InboundBatch, SerializedBottle, InventoryCase were deferred as those models don't exist yet
  - The serialization_authorized flag is key for US-B022 (serialization location blocker)
  - LocationStatus.canReceiveInventory() and canDispatchInventory() will be used by movement validation
---

## 2026-02-04 - US-B002
- **Implemented**: 8 inventory-related enums for Module B
- **Files created**:
  - app/Enums/Inventory/InboundBatchStatus.php (pending_serialization, partially_serialized, fully_serialized, discrepancy)
  - app/Enums/Inventory/BottleState.php (stored, reserved_for_picking, shipped, consumed, destroyed, missing)
  - app/Enums/Inventory/CaseIntegrityStatus.php (intact, broken)
  - app/Enums/Inventory/MovementType.php (internal_transfer, consignment_placement, consignment_return, event_shipment, event_consumption)
  - app/Enums/Inventory/MovementTrigger.php (wms_event, erp_operator, system_automatic)
  - app/Enums/Inventory/OwnershipType.php (crurated_owned, in_custody, third_party_owned)
  - app/Enums/Inventory/ConsumptionReason.php (event_consumption, sampling, damage_writeoff)
  - app/Enums/Inventory/DiscrepancyResolution.php (shortage, overage, damage, other)
- **Learnings for future iterations**:
  - LocationType and LocationStatus were already created in US-B001
  - Each enum includes helper methods beyond label/color/icon (e.g., canStartSerialization(), isAvailableForFulfillment())
  - InboundBatchStatus.canStartSerialization() will be key for serialization flow (US-B020-B023)
  - BottleState.isAvailableForFulfillment() and isTerminal() will be used by inventory service
  - CaseIntegrityStatus.canHandleAsUnit() will prevent operations on broken cases
  - OwnershipType.canConsumeForEvents() enforces only crurated_owned items can be consumed
---

## 2026-02-04 - US-B003
- **Implemented**: InboundBatch model as physical receipt record bridging procurement to serialized inventory
- **Files created**:
  - app/Models/Inventory/InboundBatch.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100001_create_inbound_batches_table.php
- **Relationships**:
  - belongsTo Location (receiving_location_id) - where batch is received
  - belongsTo Allocation (allocation_id) - preserves allocation lineage
  - morphTo productReference - polymorphic reference to wine product
- **Key fields**:
  - source_type (producer/supplier/transfer)
  - quantity_expected vs quantity_received for discrepancy tracking
  - serialization_status (uses InboundBatchStatus enum)
  - ownership_type (uses OwnershipType enum)
- **Learnings for future iterations**:
  - InboundBatch.allocation_id is the source of allocation lineage for all SerializedBottles created from it
  - getRemainingUnserializedAttribute() will need to count SerializedBottles when that model exists
  - canStartSerialization() checks both status and location.canSerialize()
  - hasDiscrepancy() compares expected vs received quantities
  - procurement_intent_id FK is nullable since ProcurementIntent model doesn't exist yet (Module D)
---

## 2026-02-04 - US-B004
- **Implemented**: SerializedBottle model as first-class object with unique identity
- **Files created**:
  - app/Models/Inventory/SerializedBottle.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100002_create_serialized_bottles_table.php
- **Files modified**:
  - app/Models/Inventory/InboundBatch.php (added serializedBottles relationship, updated getRemainingUnserializedAttribute)
  - app/Models/Inventory/Location.php (added serializedBottles and inboundBatches relationships)
- **Relationships**:
  - belongsTo WineVariant (wine_variant_id)
  - belongsTo Format (format_id)
  - belongsTo Allocation (allocation_id) - IMMUTABLE
  - belongsTo InboundBatch (inbound_batch_id)
  - belongsTo Location (current_location_id)
  - belongsTo InventoryCase (case_id) - nullable, model created in US-B005
- **Key immutability enforcement**:
  - serial_number: unique, cannot be changed after creation (DB constraint + model boot guard)
  - allocation_id: cannot be changed after creation (model boot guard)
  - Immutable fields throw InvalidArgumentException on modification attempt
- **Learnings for future iterations**:
  - InventoryCase model doesn't exist yet (US-B005), used @phpstan-ignore for case() relationship
  - Foreign key to cases table will be added when cases migration is created
  - InboundBatch.getRemainingUnserializedAttribute() now correctly counts serialized bottles
  - SerializedBottle.canConsumeForEvents() checks ownership_type.canConsumeForEvents() AND isStored()
  - All state-checking helper methods (isStored, isShipped, etc.) delegate to BottleState enum
---

## 2026-02-04 - US-B005
- **Implemented**: InventoryCase model as physical container for bottles
- **Files created**:
  - app/Models/Inventory/InventoryCase.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100003_create_cases_table.php
- **Files modified**:
  - app/Models/Inventory/SerializedBottle.php (updated case() relationship to use InventoryCase class)
  - app/Models/Inventory/Location.php (added cases() relationship)
  - app/Models/Inventory/InboundBatch.php (added cases() relationship)
- **Relationships**:
  - belongsTo CaseConfiguration (case_configuration_id)
  - belongsTo Allocation (allocation_id) - allocation lineage
  - belongsTo InboundBatch (inbound_batch_id) - nullable
  - belongsTo Location (current_location_id)
  - hasMany SerializedBottle (via case_id FK)
- **Key integrity enforcement**:
  - integrity_status: BROKEN cannot revert to INTACT (model boot guard throws InvalidArgumentException)
  - Breaking is irreversible per US-B052
- **Learnings for future iterations**:
  - Model named InventoryCase (not Case) to avoid PHP reserved keyword
  - Table is named 'cases' while model is InventoryCase
  - FK from serialized_bottles.case_id to cases.id added in this migration
  - canBreak() checks is_breakable AND isIntact() for Break Case action (US-B032)
  - bottle_count accessor counts related serializedBottles
---

## 2026-02-04 - US-B006
- **Implemented**: InventoryMovement model as immutable record of physical inventory events
- **Files created**:
  - app/Models/Inventory/InventoryMovement.php (HasUuid only, NO Auditable, NO SoftDeletes)
  - database/migrations/2026_02_04_100004_create_inventory_movements_table.php
- **Relationships**:
  - belongsTo Location (source_location_id) - nullable
  - belongsTo Location (destination_location_id) - nullable
  - belongsTo User (executed_by) - nullable
  - hasMany MovementItem (inventory_movement_id) - model created in US-B007
- **Key immutability enforcement**:
  - NO soft deletes - movements are never deleted
  - Model boot guard throws InvalidArgumentException on update attempt
  - Model boot guard throws InvalidArgumentException on delete attempt
  - Movements are append-only (insert only)
- **WMS deduplication**:
  - wms_event_id is unique nullable for deduplication
- **Learnings for future iterations**:
  - InventoryMovement does NOT use Auditable trait (movements ARE the audit log)
  - MovementItem model doesn't exist yet (US-B007), used @phpstan-ignore for relationship
  - MovementType and MovementTrigger enums already exist from US-B002
  - Helper methods delegate to enums (isWmsTriggered, isTransfer, isConsumption)
  - items_count accessor counts related movementItems
---

## 2026-02-04 - US-B007
- **Implemented**: MovementItem model as detail of items involved in inventory movements
- **Files created**:
  - app/Models/Inventory/MovementItem.php (NO Auditable, NO SoftDeletes, NO HasUuid)
  - database/migrations/2026_02_04_100005_create_movement_items_table.php
- **Files modified**:
  - app/Models/Inventory/InventoryMovement.php (removed @phpstan-ignore, fixed relationship return type)
- **Relationships**:
  - belongsTo InventoryMovement (inventory_movement_id) - required
  - belongsTo SerializedBottle (serialized_bottle_id) - nullable
  - belongsTo InventoryCase (case_id) - nullable
- **Key immutability enforcement**:
  - NO soft deletes - items are never deleted
  - Model boot guard throws InvalidArgumentException on update attempt
  - Model boot guard throws InvalidArgumentException on delete attempt
  - Items are append-only (insert only)
- **Validation**:
  - Creating hook validates at least one of serialized_bottle_id or case_id is set
- **Learnings for future iterations**:
  - MovementItem uses standard auto-incrementing id (not UUID) since it's not a standalone entity
  - MovementItem does NOT use Auditable (parent InventoryMovement is the audit record)
  - Helper methods hasBottle() and hasCase() for quick type checking
  - Uses cascadeOnDelete on inventory_movement_id FK (if parent is somehow deleted, items go too)
  - Uses nullOnDelete on serialized_bottle_id and case_id (item stays, reference becomes null)
---

## 2026-02-04 - US-B008
- **Implemented**: InventoryException model for recording inventory exceptions and audit trail
- **Files created**:
  - app/Models/Inventory/InventoryException.php (HasUuid, Auditable, SoftDeletes)
  - database/migrations/2026_02_04_100006_create_inventory_exceptions_table.php
- **Relationships**:
  - belongsTo SerializedBottle (serialized_bottle_id) - nullable
  - belongsTo InventoryCase (case_id) - nullable
  - belongsTo InboundBatch (inbound_batch_id) - nullable
  - belongsTo User (created_by) - required, the creator
  - belongsTo User (resolved_by) - nullable, the resolver
- **Key fields**:
  - exception_type: string (e.g., 'shortage', 'overage', 'damage', 'committed_consumption_override')
  - reason: required text explaining the exception
  - resolution: nullable text filled when resolved
  - resolved_at: timestamp for when exception was resolved
- **Helper methods**:
  - isResolved(), isPending() for checking resolution status
  - hasBottle(), hasCase(), hasInboundBatch() for checking related entities
- **Learnings for future iterations**:
  - InventoryException is used by US-B047 (Committed inventory consumption override) to flag exceptions for finance & ops review
  - The exception_type field is a string (not enum) for flexibility in exception types
  - Both creator and resolver relationships point to User model
  - Uses Auditable trait for created_by/updated_by audit trail
---

## 2026-02-04 - US-B009
- **Implemented**: InventoryService for centralized inventory logic
- **Files created**:
  - app/Services/Inventory/InventoryService.php
- **Methods implemented**:
  - getCommittedQuantity(Allocation): count unredeemed vouchers (Issued + Locked states)
  - getFreeQuantity(Allocation): physical bottles (stored state) - committed quantity
  - canConsume(SerializedBottle): checks if bottle can be consumed for events
  - getBottlesAtLocation(Location): returns stored bottles at a location
  - getBottlesByAllocationLineage(Allocation): returns all bottles for an allocation
- **Key logic**:
  - Committed = Vouchers in Issued or Locked lifecycle_state (NOT redeemed/cancelled)
  - Physical bottles = SerializedBottles in 'stored' state
  - canConsume checks: stored state, ownership_type.canConsumeForEvents(), free quantity > 0
- **Learnings for future iterations**:
  - Services go in app/Services/Inventory/ directory for inventory module
  - VoucherLifecycleState.Issued and .Locked are the unredeemed states
  - BottleState.Stored is the only state considered for physical availability
  - Bottle-to-voucher binding doesn't exist yet, so canConsume checks at allocation level
---

## 2026-02-04 - US-B010
- **Implemented**: SerializationService for centralized serialization logic
- **Files created**:
  - app/Services/Inventory/SerializationService.php
  - app/Jobs/Inventory/MintProvenanceNftJob.php (for async NFT minting)
- **Methods implemented**:
  - canSerializeAtLocation(Location): delegates to Location.canSerialize()
  - serializeBatch(InboundBatch, int, User): creates SerializedBottle records with full validation
  - generateSerialNumber(): generates unique CRU-YYYYMMDD-XXXXXXXX format serial numbers
  - queueNftMinting(SerializedBottle): dispatches MintProvenanceNftJob
  - updateBatchSerializationStatus(InboundBatch): updates status to pending/partial/fully_serialized
- **Key validation in serializeBatch**:
  - Quantity > 0
  - Batch.canStartSerialization() = true
  - Quantity <= remaining unserialized
  - Location.canSerialize() = true
  - Batch has allocation lineage (for immutable propagation)
  - Batch has product reference
- **Allocation lineage invariant**:
  - allocation_id is propagated from InboundBatch to every SerializedBottle created
  - This is immutable after creation (enforced in SerializedBottle model)
- **MintProvenanceNftJob**:
  - Uses exponential backoff: 10s, 60s, 300s
  - Max 3 attempts
  - Updates bottle.nft_reference and bottle.nft_minted_at on success
  - Placeholder implementation for actual blockchain integration
- **Learnings for future iterations**:
  - Jobs go in app/Jobs/Inventory/ directory for inventory module
  - Serial number format: CRU-{YYYYMMDD}-{8 random chars}
  - NFT minting is decoupled from serialization (async job)
  - getDefaultFormatId() needs UI improvement to select format explicitly
  - Discrepancy status is NOT changed by updateBatchSerializationStatus (handled separately)
---

## 2026-02-04 - US-B011
- **Implemented**: MovementService for centralized inventory movement logic
- **Files created**:
  - app/Services/Inventory/MovementService.php
- **Methods implemented**:
  - createMovement(array $data): creates InventoryMovement with MovementItems in a transaction
  - isDuplicateWmsEvent(string $wmsEventId): checks if WMS event already processed (deduplication)
  - transferBottle(SerializedBottle, Location, ?User, ?reason, ?wmsEventId): creates internal transfer and updates bottle location
  - transferCase(InventoryCase, Location, ?User, ?reason, ?wmsEventId): creates internal transfer and updates case + contained bottles locations
  - recordConsumption(SerializedBottle, ConsumptionReason, ?User, ?notes): creates consumption movement and updates bottle state to consumed
- **Key validations**:
  - createMovement: validates required fields, checks WMS event deduplication
  - transferBottle: validates bottle not in terminal state, has current location, not transferring to same location
  - transferCase: validates case canHandleAsUnit (not broken), has current location, not transferring to same location
  - recordConsumption: validates bottle is stored, ownership allows consumption for events
- **Transaction safety**:
  - All methods use DB::transaction to ensure movement creation + location/state updates are atomic
- **Learnings for future iterations**:
  - MovementType::EventConsumption is used for all consumption types (sampling, damage writeoff, event)
  - Trigger is automatically determined: WmsEvent if wms_event_id provided, otherwise ErpOperator
  - Case transfer also updates all contained bottles' locations via batch update
  - Terminal states (consumed, destroyed, missing, shipped) block bottle transfers
---

## 2026-02-04 - US-B012
- **Implemented**: LocationResource in Filament for managing physical storage points
- **Files created**:
  - app/Filament/Resources/Inventory/LocationResource.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/ListLocations.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/CreateLocation.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/ViewLocation.php
  - app/Filament/Resources/Inventory/LocationResource/Pages/EditLocation.php
- **Features implemented**:
  - Navigation group: Inventory (sort order 1)
  - List columns: name, location_type (badge), country, serialization_authorized (icon), linked_wms_id (badge), status (badge), stock_summary, updated_at
  - Filters: location_type (multi-select), country (searchable), serialization_authorized (ternary), status (with Active default), TrashedFilter
  - Search: name and country fields are searchable
  - Visual indicator for WMS: badge shows "Linked" (info color) or "Not Linked" (gray) with link icon
  - Stock summary shows count of serialized bottles at location via withCount
- **Learnings for future iterations**:
  - Filament Resources for Inventory module go in app/Filament/Resources/Inventory/ directory
  - Navigation group 'Inventory' is used for all Module B Filament resources
  - Use withCount() and custom state() for computed columns like stock_summary
  - Use formatStateUsing() with enum's label(), color(), icon() methods for enum columns
  - TrashedFilter requires getEloquentQuery() to remove SoftDeletingScope
  - View and Edit pages are placeholders for US-B013 and US-B014 respectively
---

## 2026-02-04 - US-B013
- **Implemented**: Location Detail page with 4 tabs for comprehensive location management
- **Files modified**:
  - app/Filament/Resources/Inventory/LocationResource/Pages/ViewLocation.php (complete rewrite)
- **Features implemented**:
  - Prominent serialization warning banner at top when serialization_authorized = false
  - Tab 1: Overview - Location identity, stock summary (serialized bottles, cases, unserialized inbound), bottles by state breakdown, ownership breakdown by type
  - Tab 2: Inventory - Paginated list of SerializedBottles with serial number/wine/format/state/ownership, list of Cases with configuration/integrity/bottles count
  - Tab 3: Inbound/Outbound - Recent InboundBatches with status, recent transfers in/out from InventoryMovement records
  - Tab 4: WMS Status - Connection status badge, WMS ID, last sync timestamp from WMS-triggered movements, error logs section (read-only)
- **Key patterns used**:
  - Tabs::make() with persistTabInQueryString() for tab persistence in URL
  - TextEntry with getStateUsing() for computed values and aggregations
  - RepeatableEntry for displaying related models (bottles, cases, batches)
  - Section with visible() for conditional display (e.g., WMS sections)
  - HTML generation within TextEntry for custom movement displays
- **Learnings for future iterations**:
  - PHPStan requires explicit null checks for nullable relations - use `$relation !== null ? ... : ...` pattern instead of `?->` with `??`
  - For eager-loaded relations that may not exist, assign to variable first then check null
  - executed_at on InventoryMovement is non-nullable (required field), so no null checks needed
  - Section::extraAttributes() can add custom styling classes like bg-danger-50 for warning sections
  - RepeatableEntry columns(1) forces vertical layout for better readability
  - Browser verification requirement noted - manual testing needed
---

## 2026-02-04 - US-B014
- **Implemented**: Create/Edit Location forms in Filament
- **Files modified**:
  - app/Filament/Resources/Inventory/LocationResource.php (added complete form schema)
  - app/Filament/Resources/Inventory/LocationResource/Pages/CreateLocation.php (added redirect to view)
  - app/Filament/Resources/Inventory/LocationResource/Pages/EditLocation.php (added beforeSave warning, redirect to view)
- **Features implemented**:
  - Form sections: Location Details (name, location_type, country, address), Settings (serialization_authorized, linked_wms_id, status), Notes (collapsible)
  - Name uniqueness validation with `withoutTrashed()` modifier
  - Prominent warning banner when disabling serialization_authorized on location with pending serialization batches
  - Live reactive toggle for serialization_authorized to show/hide warning dynamically
  - Notification sent on save when disabling serialization with pending batches
  - Redirect to view page after create/edit
- **Audit logging**:
  - Handled automatically by Auditable trait on Location model
  - All create/update/delete events logged to AuditLog table
- **Learnings for future iterations**:
  - Use `Forms\Get $get` with `->live()` on toggle to make warning section reactive
  - `->unique(modifyRuleUsing: fn (Unique $rule) => $rule->withoutTrashed())` ensures soft-deleted records don't conflict with uniqueness
  - `beforeSave()` hook in EditRecord is ideal for validation warnings that don't block save
  - Section::make()->extraAttributes() adds custom CSS classes for visual prominence
  - Browser verification requirement noted - manual testing needed
---
