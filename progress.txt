# Ralph Progress Log
Started: Wed Feb  4 08:12:32 CET 2026
---

## Codebase Patterns
- Use `HasUuid` trait for UUID primary keys with `$table->uuid('id')->primary()` in migrations
- Use `Auditable` trait with `created_by`/`updated_by` columns and `auditLogs()` MorphMany relationship
- Use `SoftDeletes` trait with `$table->softDeletes()` in migrations
- Customer module enums go in `App\Enums\Customer\` namespace
- Customer module models go in `App\Models\Customer\` namespace
- Enums need `label()`, `color()`, and `icon()` methods for Filament compatibility
- Migration naming: `YYYY_MM_DD_XXXXXX_create_table_name_table.php`
- Use `foreignId()->constrained()->nullOnDelete()` for FK references to users table
- Use `foreignUuid()->constrained()->cascadeOnDelete()` for FK references to UUID tables (Module K uses UUIDs)
- Filament Resources for Customer module go in `App\Filament\Resources\Customer\` namespace
- For PHPStan on Filament bulk actions, add `/** @var Collection<int, ModelName> $records */` PHPDoc before each() call

---

## 2026-02-04 - US-001
- What was implemented:
  - Created `PartyType` enum (individual, legal_entity) with label/color/icon methods
  - Created `PartyStatus` enum (active, inactive) with label/color/icon methods
  - Created `Party` model with HasUuid, Auditable, SoftDeletes traits
  - Created migration for `parties` table with unique constraint on (tax_id, jurisdiction)
  - Created `PartyRole` stub model for relationship placeholder (full implementation in US-002)
- Files changed:
  - app/Enums/Customer/PartyType.php (new)
  - app/Enums/Customer/PartyStatus.php (new)
  - app/Models/Customer/Party.php (new)
  - app/Models/Customer/PartyRole.php (new - stub)
  - database/migrations/2026_02_04_390000_create_parties_table.php (new)
- **Learnings for future iterations:**
  - Customer module uses `App\Enums\Customer\` and `App\Models\Customer\` namespaces
  - Migration sequence for Module K starts at 390000
  - PartyRole stub created to satisfy Party relationship, will be completed in US-002
---

## 2026-02-04 - US-002
- What was implemented:
  - Created `PartyRoleType` enum (customer, supplier, producer, partner) with label/color/icon methods
  - Completed `PartyRole` model with HasUuid, Auditable traits and role type casting
  - Created migration for `party_roles` table with FK to parties and unique constraint on (party_id, role)
  - Updated `Party` model with addRole/removeRole methods and role checking helpers (isCustomer, isSupplier, isProducer, isPartner)
- Files changed:
  - app/Enums/Customer/PartyRoleType.php (new)
  - app/Models/Customer/PartyRole.php (updated from stub)
  - app/Models/Customer/Party.php (updated - added role helpers)
  - database/migrations/2026_02_04_390001_create_party_roles_table.php (new)
- **Learnings for future iterations:**
  - Use `foreignUuid()->constrained()->cascadeOnDelete()` for FK references to UUID tables (vs foreignId for int tables)
  - Migration sequence continues: 390001 for party_roles
  - Party model uses union type `PartyRoleType|string` to accept both enum and string values for backward compatibility
---

## 2026-02-04 - US-003
- What was implemented:
  - Created `PartyResource` Filament resource in `App\Filament\Resources\Customer` namespace
  - List view with columns: legal_name, party_type (badge), roles (badges), jurisdiction, status (badge), tax_id, vat_number, updated_at
  - Filters: party_type, role (with custom query for relationship), status, jurisdiction (dynamic), TrashedFilter
  - Search on: legal_name, tax_id, vat_number
  - Bulk actions: activate, deactivate with confirmation
  - CRUD pages: ListParties, CreateParty, ViewParty, EditParty
  - Added "Customers" navigation group to AdminPanelProvider
- Files changed:
  - app/Providers/Filament/AdminPanelProvider.php (updated - added Customers navigation group)
  - app/Filament/Resources/Customer/PartyResource.php (new)
  - app/Filament/Resources/Customer/PartyResource/Pages/ListParties.php (new)
  - app/Filament/Resources/Customer/PartyResource/Pages/CreateParty.php (new)
  - app/Filament/Resources/Customer/PartyResource/Pages/ViewParty.php (new)
  - app/Filament/Resources/Customer/PartyResource/Pages/EditParty.php (new)
- **Learnings for future iterations:**
  - Filament Resources in Customer module go in `App\Filament\Resources\Customer\` namespace
  - Use `->with('roles')` in `getEloquentQuery()` to eager load relationships for list display
  - For bulk actions with Collection, use PHPDoc annotation `/** @var Collection<int, Model> $records */` before the each() call to satisfy PHPStan
  - Role filter needs custom query using `whereHas()` to filter by relationship
  - Navigation groups must be defined in AdminPanelProvider's `navigationGroups()` array
---

## 2026-02-04 - US-004
- What was implemented:
  - Extended `ViewParty` page with tabs using Filament Infolists Tabs component
  - Tab Overview: identity summary with Party ID, legal name, party type, status, created/updated dates, and assigned roles
  - Tab Roles: list of assigned roles with add role (modal form) and remove role (confirmation) actions
  - Tab Legal: tax_id, vat_number, jurisdiction fields with compliance notes section (placeholder)
  - Tab Audit: full audit trail timeline with filters (event type, date range), shows user, timestamp, and changes
  - Header actions: Activate/Deactivate contextual actions that show/hide based on party status
- Files changed:
  - app/Filament/Resources/Customer/PartyResource/Pages/ViewParty.php (updated - complete rewrite with tabs)
- **Learnings for future iterations:**
  - Use `Tabs::make()->tabs([...])` with `persistTabInQueryString()` for persistent tab state
  - For repeatable entries with actions, use `RepeatableEntry` with `\Filament\Infolists\Components\Actions\Action` inside
  - Audit trail pattern: use `getStateUsing()` with HTML output for custom timeline rendering
  - Header section actions use `\Filament\Infolists\Components\Actions\Action` (different from `Filament\Actions\Action`)
  - For modal forms in infolist actions, use standard Filament form components in the `form()` method
  - Tab badges show counts using `badge()` method, e.g., `->badge($count > 0 ? (string) $count : null)`
---

## 2026-02-04 - US-005
- What was implemented:
  - Created `CustomerType` enum (b2c, b2b, partner) with label/color/icon methods
  - Created `CustomerStatus` enum (prospect, active, suspended, closed) with label/color/icon methods
  - Enhanced existing `Customer` model with Party relationship, Auditable trait, and Module K fields
  - Created migration to add Module K fields to existing customers table (party_id FK, customer_type, default_billing_address_id, created_by, updated_by)
  - Created `PartyRoleObserver` to auto-create Customer when Party receives customer role
  - Added backward-compatible STATUS_* constants to Customer model for existing code compatibility
  - Updated ViewCustomer page to use CustomerStatus enum for badge colors/icons
- Files changed:
  - app/Enums/Customer/CustomerType.php (new)
  - app/Enums/Customer/CustomerStatus.php (new)
  - app/Models/Customer/Customer.php (updated - added Party relationship, enum casts, backward-compat constants)
  - app/Observers/Customer/PartyRoleObserver.php (new)
  - app/Providers/AppServiceProvider.php (updated - registered PartyRoleObserver)
  - app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php (updated - use CustomerStatus enum)
  - database/migrations/2026_02_04_390002_add_module_k_fields_to_customers_table.php (new)
- **Learnings for future iterations:**
  - When enhancing existing models with enum status, keep backward-compatible constants for existing code (deprecated)
  - Module K migrations alter existing tables: use `Schema::table()` with `after()` to position new columns
  - Observer pattern is clean way to auto-create related models when roles are assigned
  - Observers are registered in AppServiceProvider's `boot()` method using `Model::observe(Observer::class)`
  - Migration sequence continues: 390002 for customers table enhancement
---

## 2026-02-04 - US-006
- What was implemented:
  - Created `ChannelScope` enum (b2c, b2b, club) with label/color/icon methods
  - Created `AccountStatus` enum (active, suspended) with label/color/icon methods
  - Created `Account` model with HasUuid, Auditable, SoftDeletes traits
  - Created migration for `accounts` table with FK to customers
  - Added `accounts()` hasMany relationship to Customer model
- Files changed:
  - app/Enums/Customer/ChannelScope.php (new)
  - app/Enums/Customer/AccountStatus.php (new)
  - app/Models/Customer/Account.php (new)
  - app/Models/Customer/Customer.php (updated - added accounts relationship)
  - database/migrations/2026_02_04_390003_create_accounts_table.php (new)
- **Learnings for future iterations:**
  - Account model represents operational contexts for a Customer
  - A Customer can have multiple Accounts with different channel scopes
  - Migration sequence continues: 390003 for accounts table
  - Account inherits restrictions from Customer but can add its own (to be implemented in later stories)
---

## 2026-02-04 - US-007
- What was implemented:
  - Updated CustomerResource to be the primary operational screen for customer management
  - Columns: display_name (via Party/legacy), customer_type (badge), membership_tier (placeholder), status (badge), accounts_count, has_active_blocks indicator, email, tax_id (via Party), updated_at
  - Filters: customer_type, status, membership_tier (placeholder), has_blocks (placeholder), TrashedFilter
  - Search on: name, party.legal_name, email, party.tax_id
  - Quick actions: view, suspend (visible when active), activate (visible when suspended/prospect)
  - Bulk actions: suspend, activate, delete, restore
  - Eager loads party and accounts relationships for performance
  - Updated form to use CustomerType and CustomerStatus enums
- Files changed:
  - app/Filament/Resources/Customer/CustomerResource.php (updated - complete rewrite of table() method)
- **Learnings for future iterations:**
  - Use `->state()` callback for computed columns like display_name that don't map to database fields
  - For searchable computed columns, use `->searchable(query: fn())` to define custom search logic
  - membership_tier and has_active_blocks are placeholders until US-011 and US-027 are implemented
  - Use `->visible(fn())` on actions for conditional display based on record state
  - Eager load with `->with(['party', 'accounts'])` and `->withCount('accounts')` in getEloquentQuery()
---

## 2026-02-04 - US-008
- What was implemented:
  - Complete rewrite of ViewCustomer page with 9 thematic tabs
  - Tab Overview: customer identity (ID, name, email, customer_type, status, party info, tax_id), quick summary (accounts count, vouchers count, membership tier placeholder, active blocks placeholder), assets summary (vouchers and cases by status)
  - Tab Membership: placeholder sections for tier, status, effective date, lifecycle timeline, and decision history
  - Tab Accounts: displays customer's accounts with ID, name, channel_scope, status, created_at using RepeatableEntry
  - Tab Addresses: placeholder sections for billing and shipping addresses
  - Tab Eligibility: placeholder showing B2C/B2B/Club channel eligibility with factors (to be computed by engine)
  - Tab Payment & Credit: placeholder showing card_allowed, bank_transfer_allowed, credit_limit permissions
  - Tab Clubs: placeholder for club affiliations and their eligibility impact
  - Tab Operational Blocks: placeholder showing active blocks, block types explanation, and history
  - Tab Audit: full audit trail with filters (event type, date range) using same HTML rendering pattern as ViewParty
  - Added header actions: Suspend (visible when Active), Activate (visible when Prospect/Suspended)
  - Added getSubheading() to show customer type and status badges
  - Title uses Customer.getName() method for Party-aware display
- Files changed:
  - app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php (updated - complete rewrite with 9 tabs)
- **Learnings for future iterations:**
  - ViewCustomer now follows same pattern as ViewParty with Tabs, Sections, and audit trail rendering
  - Each placeholder tab references the future US story that will implement the full functionality
  - Use `->collapsed()` and `->collapsible()` on sections for progressive disclosure
  - Audit trail filtering uses Livewire properties ($auditEventFilter, $auditDateFrom, $auditDateUntil)
  - Header actions pattern: Suspend visible when Active, Activate visible when Prospect or Suspended
  - Customer.getName() method handles both Party-linked and legacy customers gracefully
---

## 2026-02-04 - US-009
- What was implemented:
  - Full Account management CRUD within the Customer Detail Accounts tab
  - Create Account: modal form with name (required, max 255 chars) and channel_scope (select from ChannelScope enum)
  - Edit Account: modal form pre-populated with current values, updates name and channel_scope
  - Suspend Account: confirmation modal, changes status to Suspended, only visible when Active
  - Activate Account: confirmation modal, changes status to Active, only visible when Suspended
  - Delete Account: confirmation modal with soft delete, available regardless of status (no transactions constraint yet - to be implemented when transactions are added)
  - Updated grid from 5 to 6 columns to accommodate action buttons
  - Actions aligned to end of row using `->alignEnd()`
  - All actions use proper Notification feedback pattern
  - Uses `$this->refreshFormData(['accounts'])` to refresh the accounts list after any action
- Files changed:
  - app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php (updated - full CRUD in Accounts tab)
- **Learnings for future iterations:**
  - For inline actions on RepeatableEntry items, use `\Filament\Infolists\Components\Actions::make([...])` with `->alignEnd()` in the Grid
  - Modal forms in infolist actions use standard Filament form components (TextInput, Select, etc.)
  - Use `fn (Model $model): array => [...]` syntax to pre-populate form defaults from the current record
  - Use `fn (Model $model): string => "..."` for dynamic modal descriptions
  - The `->visible(fn (Model $model): bool => ...)` pattern controls conditional action visibility based on record state
  - Account.delete() uses soft deletes via SoftDeletes trait - no hard delete needed
  - Delete constraint "only if no transactions" is a placeholder until transactions are implemented in future stories
---

## 2026-02-04 - US-010
- What was implemented:
  - Created `AddressType` enum (billing, shipping) with label/color/icon methods for Filament compatibility
  - Created `Address` model with HasUuid, Auditable, SoftDeletes traits
  - Created polymorphic migration for `addresses` table with FK to users for created_by/updated_by
  - Added `addresses()`, `billingAddresses()`, `shippingAddresses()` relationships to Customer model
  - Added helper methods: `getDefaultBillingAddress()`, `getDefaultShippingAddress()`, `hasBillingAddress()`, `hasShippingAddress()`
  - Implemented full Addresses tab CRUD in Customer Detail with two sections (Billing and Shipping)
  - Create Address: modal form with line_1, line_2, city, state, postal_code, country, is_default toggle
  - Edit Address: modal form pre-populated with current values
  - Set Default: action that unsets other defaults of same type and sets selected as default
  - Delete Address: confirmation modal with soft delete
  - First address of each type automatically becomes default
  - Created `CustomerObserver` to validate billing address requirement when activating a Customer
  - Updated Activate Customer action to check billing address and show appropriate message
- Files changed:
  - app/Enums/Customer/AddressType.php (new)
  - app/Models/Customer/Address.php (new)
  - app/Models/Customer/Customer.php (updated - added address relationships and helpers)
  - app/Observers/Customer/CustomerObserver.php (new)
  - app/Providers/AppServiceProvider.php (updated - registered CustomerObserver)
  - app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php (updated - full CRUD in Addresses tab)
  - database/migrations/2026_02_04_390004_create_addresses_table.php (new)
- **Learnings for future iterations:**
  - Polymorphic relationships use `addressable_type` and `addressable_id` columns (using UUID for id)
  - Use `MorphTo` for the parent relationship and `MorphMany` for child collections
  - Split addresses into separate sections (Billing/Shipping) for clarity
  - Use `getFormattedAddress()` and `getOneLine()` helpers for display
  - `setAsDefault()` method handles unsetting other defaults atomically
  - Observer pattern works well for enforcing business rules on status changes
  - Pint requires `concat_space` - use `.` without spaces for string concatenation
  - Migration sequence continues: 390004 for addresses table
---

## 2026-02-04 - US-011
- What was implemented:
  - Created `MembershipTier` enum (legacy, member, invitation_only) with label/color/icon/description methods
  - Created `MembershipStatus` enum (applied, under_review, approved, rejected, suspended) with label/color/icon methods
  - Added `validTransitions()` and `canTransitionTo()` methods on MembershipStatus for workflow state machine
  - Created `Membership` model with HasUuid, Auditable traits
  - Created migration for `memberships` table with FK to customers, tier, status, effective dates, and decision_notes
  - Added `memberships()` hasMany relationship to Customer for historical records
  - Added `membership()` hasOne relationship using `latestOfMany()` for current membership
  - Added `activeMembership()` hasOne relationship for active approved membership within effective dates
  - Added helper methods: `hasActiveMembership()`, `getMembershipTier()`, `getMembershipStatus()`
  - Added scopes on Membership: `scopeActive()`, `scopeCurrent()`
- Files changed:
  - app/Enums/Customer/MembershipTier.php (new)
  - app/Enums/Customer/MembershipStatus.php (new)
  - app/Models/Customer/Membership.php (new)
  - app/Models/Customer/Customer.php (updated - added membership relationships and helpers)
  - database/migrations/2026_02_04_390005_create_memberships_table.php (new)
- **Learnings for future iterations:**
  - Use `latestOfMany()` for hasOne relationship to get the most recent record from a hasMany
  - Membership status enum includes `validTransitions()` for state machine workflow validation
  - A Customer can have one active Membership (approved + within effective dates) but multiple historical records
  - Migration sequence continues: 390005 for memberships table
  - Use `HasOne` with query constraints for relationships like `activeMembership()` that filter by status and dates
---

## 2026-02-04 - US-012
- What was implemented:
  - Enhanced `MembershipTier` enum with channel eligibility computation methods
  - Added `eligibleChannels()` to return array of ChannelScope values the tier grants access to
  - Added `isEligibleForChannel(ChannelScope)` to check tier-based eligibility for a specific channel
  - Added `hasAutomaticClubAccess()` - Legacy and InvitationOnly tiers get automatic Club access
  - Added `requiresApproval()` - Member and InvitationOnly require approval process
  - Added `hasExclusiveProductAccess()` - Legacy and InvitationOnly have exclusive product access
  - Added `priority()` and `isHigherThan()` for tier comparison/upgrade paths
  - Added `getChannelEligibilityReasons()` for human-readable eligibility explanations
  - Extended Membership model with eligibility proxy methods that also check status
  - Extended Customer model with `isMembershipEligibleForChannel()`, `hasAutomaticClubAccess()`, `hasExclusiveProductAccess()`, `getMembershipChannelEligibilityReasons()`
- Files changed:
  - app/Enums/Customer/MembershipTier.php (updated - added channel eligibility methods)
  - app/Models/Customer/Membership.php (updated - added eligibility proxy methods)
  - app/Models/Customer/Customer.php (updated - added customer-level eligibility helpers)
- **Learnings for future iterations:**
  - Channel eligibility is tiered: MembershipTier defines base eligibility, Membership checks status, Customer provides convenient access
  - Legacy tier is grandfathered with highest priority (3), full access to everything
  - Member tier (priority 1) is standard, requires Club affiliation for Club channel access
  - InvitationOnly tier (priority 2) has full access like Legacy plus exclusive product benefits
  - Eligibility reasons follow `array<string, array{eligible: bool, reason: string}>` format for human-readable explanations
  - This eligibility logic will be consumed by EligibilityEngine (US-015) for complete channel eligibility computation
---

## 2026-02-04 - US-013
- What was implemented:
  - Fully functional Membership Tab in Customer Detail with workflow actions
  - Current Membership section showing: tier (with description), status (with badge), effective_from, effective_to, decision_notes
  - Membership Lifecycle visual timeline with 3-step progress indicator (Applied → Under Review → Approved)
  - Timeline handles special states: Rejected (shows red), Suspended (shows gray on approved stage)
  - Status description explains the current state and next steps
  - Decision History section showing all membership records with tier, status, dates, and notes
  - Workflow Actions (appear based on current state):
    - Apply for Membership: creates new membership in Applied status (when no membership or rejected)
    - Submit for Review: transitions Applied → Under Review
    - Approve: transitions Under Review → Approved (sets effective_from to now)
    - Reject: transitions Under Review → Rejected (requires decision notes)
    - Suspend: transitions Approved → Suspended (requires decision notes)
    - Reactivate: transitions Suspended → Approved
  - Updated Overview tab to show actual membership tier instead of placeholder
- Files changed:
  - app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php (updated - full Membership tab implementation)
- **Learnings for future iterations:**
  - Use `->headerActions()` on Section to add workflow action buttons
  - Workflow actions should be conditional based on current state using separate if blocks (not visible callback)
  - Decision notes should be required for negative actions (Reject, Suspend) using `->required()` in form
  - Visual timeline can be built using HTML with Tailwind classes in a TextEntry with `->html()`
  - Tab badge can show the current membership status for quick visibility
  - Match expressions must be exhaustive for all enum cases - add Rejected/Suspended to catch-all arms when they won't actually be reached
  - Section does not have a `badge()` method in Filament Infolists - use string concatenation in section title instead
  - For repeatable entries from relationships, the collection is already available through the relationship
---

## 2026-02-04 - US-014
- What was implemented:
  - Created `InvalidMembershipTransitionException` in `App\Exceptions\` for user-friendly error messages
  - Added `transitionTo()` method in Membership model with validation - throws exception if transition invalid
  - Added convenience methods: `submitForReview()`, `approve()`, `reject()`, `suspend()`, `reactivate()`
  - Added `getTransitionErrorMessage()` helper for building user-friendly messages
  - Added `canApproveMemberships()` to User model (requires Manager role via `hasAtLeast()`)
  - Updated ViewCustomer to use `canTransitionTo()` for action visibility
  - Approve and Reject actions now check `canApproveMemberships` with disabled state and tooltip
  - All actions wrapped in try-catch for InvalidMembershipTransitionException with danger notification
  - `effective_from` is automatically set in `transitionTo()` when transitioning to Approved
  - All transitions logged via existing Auditable trait (user_id, timestamp, changes)
- Files changed:
  - app/Exceptions/InvalidMembershipTransitionException.php (new)
  - app/Models/Customer/Membership.php (updated - added transition methods)
  - app/Models/User.php (updated - added canApproveMemberships())
  - app/Filament/Resources/Customer/CustomerResource/Pages/ViewCustomer.php (updated - authorization and validation)
- **Learnings for future iterations:**
  - Create custom exceptions in `App\Exceptions\` namespace for domain-specific errors
  - Use `->disabled()` with `->tooltip()` pattern to show disabled actions with explanation
  - Transitions should use model methods (e.g., `approve()`) rather than direct `update()` for encapsulation
  - The `canTransitionTo()` check in UI conditions prevents buttons from showing for invalid transitions
  - Authorization checks should be done both in UI (disabled) and action callback (early return) for security
  - Named parameters like `autoSetEffectiveFrom: false` make method calls more readable
  - User::canApproveMemberships() follows the existing pattern of User::canApprovePriceBooks()
---
