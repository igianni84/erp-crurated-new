# Ralph Progress Log
Started: Tue Feb  3 18:51:45 CET 2026
---

## Codebase Patterns
- Enums should be PHP 8.1+ backed enums with `label()`, `color()`, and `icon()` helper methods for Filament integration
- Allocation-related enums go in `app/Enums/Allocation/`
- Use wine_variant_id + format_id as bottle SKU reference (no separate BottleSku model exists)
- Jobs go in `app/Jobs/{Module}/` - schedule in `routes/console.php` using `Schedule::job()->everyMinute()`
- Services go in `app/Services/{Module}/` - use DB::transaction() with lockForUpdate() for atomic quantity operations
- Filament Resources go in `app/Filament/Resources/{Module}/` with Pages subdirectory - use enum methods for badge styling
- Filament Wizard forms: use `CreateRecord\Concerns\HasWizard` trait in CreateXxx page class, override `form()` and `getSteps()`

---

## 2026-02-03 - US-002
- What was implemented: Verified that all three allocation enums already exist and meet acceptance criteria
- Files verified (no changes needed):
  - `app/Enums/Allocation/AllocationSourceType.php`
  - `app/Enums/Allocation/AllocationSupplyForm.php`
  - `app/Enums/Allocation/AllocationStatus.php`
- **Learnings for future iterations:**
  - Enums were created as part of US-001 setup, so this story was already complete
  - AllocationStatus includes transition helpers: `allowedTransitions()`, `canTransitionTo()`, `allowsConstraintEditing()`, `allowsConsumption()`, `isTerminal()`
  - All enums follow Filament patterns with label/color/icon methods
---

## 2026-02-03 - US-003
- What was implemented: AllocationConstraint model for authoritative commercial constraints on allocations
- Files changed:
  - `database/migrations/2026_02_03_260000_create_allocation_constraints_table.php` (new)
  - `app/Models/Allocation/AllocationConstraint.php` (new)
  - `app/Models/Allocation/Allocation.php` (added hasOne relationship and auto-create on allocation creation)
- **Learnings for future iterations:**
  - AllocationConstraint is automatically created when an Allocation is created (via `created` event in Allocation model boot)
  - Constraints can only be edited when Allocation is in Draft status (validated in AllocationConstraint's `updating` event)
  - The `constraint()` relationship uses HasOne pattern; the FK is `allocation_id` on the constraints table with unique constraint
  - JSON array fields use `'array'` cast in Laravel and `@property array<string>|null` PHPDoc for PHPStan
  - Helper methods: `getAllChannels()`, `getAllCustomerTypes()` return available options; `isChannelAllowed()`, etc. for constraint checking
---

## 2026-02-03 - US-004
- What was implemented: LiquidAllocationConstraint model for liquid-specific allocation constraints
- Files changed:
  - `database/migrations/2026_02_03_270000_create_liquid_allocation_constraints_table.php` (new)
  - `app/Models/Allocation/LiquidAllocationConstraint.php` (new)
  - `app/Models/Allocation/Allocation.php` (added liquidConstraint() relationship and isLiquid()/isBottled() helpers)
- **Learnings for future iterations:**
  - LiquidAllocationConstraint has a `saving` event that validates `allocation.supply_form === AllocationSupplyForm::Liquid`
  - Unlike AllocationConstraint, LiquidAllocationConstraint is NOT auto-created on Allocation creation (only applicable for liquid allocations)
  - Both constraint models follow the same pattern: unique FK to allocation_id, `updating` event to prevent edits on non-Draft allocations
  - Added `isLiquid()` and `isBottled()` helper methods to Allocation model for easier supply_form checks
---

## 2026-02-03 - US-005
- What was implemented: TemporaryReservation model for temporary holds on allocation quantity to prevent overselling
- Files changed:
  - `database/migrations/2026_02_03_280000_create_temporary_reservations_table.php` (new)
  - `app/Models/Allocation/TemporaryReservation.php` (new)
  - `app/Enums/Allocation/ReservationContextType.php` (new) - checkout, negotiation, manual_hold
  - `app/Enums/Allocation/ReservationStatus.php` (new) - active, expired, cancelled, converted
  - `app/Jobs/Allocation/ExpireReservationsJob.php` (new) - scheduled job to expire reservations
  - `app/Models/Allocation/Allocation.php` (added temporaryReservations() and activeReservations() relationships)
  - `routes/console.php` (added scheduled job registration)
- **Learnings for future iterations:**
  - TemporaryReservation does NOT consume allocation - it only "blocks" quantity temporarily
  - ReservationStatus has `isActive()`, `isTerminal()`, `allowedTransitions()`, `canTransitionTo()` helpers like AllocationStatus
  - Model includes helper methods: `expire()`, `cancel()`, `convert()` for state transitions
  - Scopes `active()` and `needsExpiration()` are available for querying
  - Jobs go in `app/Jobs/{Module}/` directory structure
  - Laravel 11+ scheduling is done in `routes/console.php` using `Schedule::job()->everyMinute()`
---

## 2026-02-03 - US-006
- What was implemented: AllocationService for centralizing allocation business logic
- Files changed:
  - `app/Services/Allocation/AllocationService.php` (new)
- **Methods implemented:**
  - `activate(Allocation)`: draft → active transition
  - `close(Allocation)`: active/exhausted → closed transition
  - `consumeAllocation(Allocation, quantity)`: decrements remaining, increments sold with DB transaction locking
  - `checkAvailability(Allocation, quantity)`: checks if quantity is available (remaining - active_reservations >= quantity)
  - `getRemainingAvailable(Allocation)`: returns remaining - sum(active_reservations.quantity)
  - `canActivate(Allocation)`, `canClose(Allocation)`: helper methods for checking allowed transitions
  - `markAsExhausted(Allocation)`: active → exhausted transition (auto-called when remaining reaches 0)
- **Learnings for future iterations:**
  - Services go in `app/Services/{Module}/` directory structure
  - Use `DB::transaction()` with `lockForUpdate()` for atomic operations that modify quantities
  - Always double-check availability after acquiring lock to prevent race conditions
  - Status transitions should auto-trigger where appropriate (e.g., exhausted when remaining=0)
  - Use explicit exception messages that explain what's wrong and how to fix it
---

## 2026-02-03 - US-007
- What was implemented: AllocationResource for Filament admin panel with comprehensive list view
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/ListAllocations.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/ViewAllocation.php` (new)
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/EditAllocation.php` (new)
- **Features implemented:**
  - Navigation group 'Allocations' with cube-transparent icon
  - All required columns: id, bottle_sku, supply_form, source_type, status, total_qty, sold_qty, remaining_qty, availability_window, constraint_summary, updated_at
  - Status, source_type, supply_form shown as badges with colors and icons from enums
  - Near exhaustion indicator: remaining_qty shows danger color, bold text, and warning icon when < 10%
  - Filters: status (multi-select, default excludes Closed), source_type (multi-select), supply_form, wine_variant/bottle_sku, near_exhaustion toggle, trashed
  - Search: wine name, producer, allocation ID via searchable columns
  - Eager loading of relationships (wineVariant.wineMaster, format, constraint) via modifyQueryUsing
- **Learnings for future iterations:**
  - Filament Resources go in `app/Filament/Resources/{Module}/` with Pages subdirectory
  - Use `formatStateUsing()` with enum's `label()` method for badge text
  - Use `color()` and `icon()` from enum for badge styling
  - For computed columns, use `state()` callback to call model methods like `getBottleSkuLabel()`
  - For searchable computed columns, use `searchable(query: ...)` with custom query builder
  - Use `modifyQueryUsing()` on table for eager loading relationships
  - Default filter values with `->default()` to pre-populate filter (e.g., exclude Closed status)
---

## 2026-02-03 - US-008
- What was implemented: Create Allocation wizard - Step 1 (Bottle SKU selection)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (modified to add wizard)
- **Features implemented:**
  - Wizard-based form using `CreateRecord\Concerns\HasWizard` trait
  - Step 1: Bottle SKU selection with cascading selects:
    - Wine selection via autocomplete search (searches by name or producer)
    - Vintage selection (dynamically filtered by selected WineMaster)
    - Format selection (all available formats ordered by volume_ml)
  - Bottle SKU preview showing full label: Wine (Producer) Vintage - Format
  - Info message: "Allocation always happens at Bottle SKU level (Wine + Vintage + Format)"
  - `mutateFormDataBeforeCreate()` removes temporary wine_master_id field
- **Learnings for future iterations:**
  - Use `CreateRecord\Concerns\HasWizard` trait for multi-step forms
  - For cascading selects: use `live()` + `afterStateUpdated()` to reset dependent fields
  - Use `hidden()` with `Get` callback to show/hide sections based on previous selections
  - Use `getSearchResultsUsing()` for custom autocomplete search logic
  - Use `getOptionLabelUsing()` to format existing option labels for display
  - Use `getAttribute()` instead of direct property access to avoid PHPStan strict type errors
---

## 2026-02-03 - US-009
- What was implemented: Create Allocation wizard - Step 2 (Source & Capacity)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getSourceAndCapacityStep method)
- **Features implemented:**
  - Source Type select with all AllocationSourceType enum options (producer_allocation, owned_stock, passive_consignment, third_party_custody)
  - Supply Form select with AllocationSupplyForm enum options (bottled, liquid)
  - Live inline guidance explaining implications of bottled vs liquid supply:
    - Bottled: ready for sale, individual serialization
    - Liquid: still in barrel/tank, bottling options may apply, additional constraints in Step 4
  - Total Quantity numeric input with minValue(1) validation and "bottles" suffix
  - Availability Window with start/end date pickers, afterOrEqual validation for end date
  - Serialization Required toggle (default true) with live inline guidance:
    - Enabled: unique identifier for provenance tracking, recommended for fine wine
    - Disabled: bottles not individually tracked, for commodity wines only
- **Learnings for future iterations:**
  - Use `live()` on fields that need to update guidance Placeholders dynamically
  - Use `native(false)` on Select components for better Filament-styled dropdowns
  - Use `afterOrEqual()` validation on DatePicker for date range validation (cleaner than custom rules)
  - Placeholder components with markdown (**bold**) work for inline guidance
  - Each step method returns a Wizard\Step - add to getSteps() array
---

## 2026-02-03 - US-010
- What was implemented: Create Allocation wizard - Step 3 (Commercial Constraints)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getCommercialConstraintsStep method, updated getSteps, mutateFormDataBeforeCreate, and added afterCreate)
- **Features implemented:**
  - Step 3: Commercial Constraints with shield-check icon
  - Prominent warning message: "⚠️ AUTHORITATIVE CONSTRAINTS — These constraints are binding and will be enforced by Module S"
  - CheckboxList for allowed_channels with options: b2c, b2b, private_sales, wholesale, club (displayed in 2 columns)
  - TagsInput for allowed_geographies (flexible input for ISO country/region codes)
  - CheckboxList for allowed_customer_types with options: retail, trade, private_client, club_member, internal (displayed in 2 columns)
  - Helper text explaining default behavior: empty = all allowed
  - Info note about constraints becoming read-only after activation
  - Nested form data handling via session storage + afterCreate hook to update AllocationConstraint
- **Learnings for future iterations:**
  - Use `constraint.field_name` dot notation for nested related model fields in wizard forms
  - For related model data in creation wizards, use session storage in `mutateFormDataBeforeCreate()` and apply in `afterCreate()` hook
  - CheckboxList with `->columns(2)` for compact multi-select display
  - TagsInput is flexible for user-defined values (like geography codes) vs CheckboxList for predefined options
  - Use PHPDoc `@var` type hints to help PHPStan understand `$this->record` type in afterCreate
---

## 2026-02-03 - US-011
- What was implemented: Create Allocation wizard - Step 4 (Advanced/Liquid Constraints)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getAdvancedConstraintsStep method, updated getSteps, mutateFormDataBeforeCreate, and afterCreate)
- **Features implemented:**
  - Step 4: Advanced Constraints with adjustments-horizontal icon
  - Liquid Allocation Constraints section (visible/expanded only when supply_form = liquid):
    - allowed_bottling_formats (TagsInput) - customers can choose from specified formats
    - allowed_case_configurations (TagsInput) - packaging options for customers
    - bottling_confirmation_deadline (DatePicker) - deadline for bottling preferences
    - Inline guidance explaining liquid allocation requirements
  - Advanced Commercial Constraints section (always available, collapsed by default for bottled, expanded for liquid):
    - composition_constraint_group (TextInput) - for vertical cases and themed selections
    - fungibility_exception (Toggle) - for non-interchangeable bottles
    - Inline guidance explaining composition groups and fungibility exceptions
  - Tip message for bottled allocations that advanced constraints are optional
  - LiquidAllocationConstraint created in afterCreate hook for liquid allocations with specified data
- **Learnings for future iterations:**
  - Use `->hidden()` combined with `->collapsed()` and `->collapsible()` to control section visibility and state based on other form fields
  - For liquid-specific related models (LiquidAllocationConstraint), create them in afterCreate only when the allocation is liquid using `$allocation->isLiquid()` helper
  - Session storage pattern works well for multiple related model data: store in `mutateFormDataBeforeCreate()`, apply in `afterCreate()`
  - Use `liquid_constraint.field_name` dot notation pattern consistent with `constraint.field_name` for nested model fields
---

## 2026-02-03 - US-012
- What was implemented: Create Allocation wizard - Step 5 (Review & Create)
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/CreateAllocation.php` (added getReviewStep method, getWizardSubmitActions, createAsDraft, createAndActivate, updated afterCreate)
  - `app/Policies/AllocationPolicy.php` (new) - Authorization policy for Allocation model
  - `app/Providers/AppServiceProvider.php` (updated to register AllocationPolicy)
- **Features implemented:**
  - Step 5: Review & Create with check-badge icon
  - Read-only summary sections for: Bottle SKU, Source & Capacity, Commercial Constraints
  - Advanced Constraints section (shown only if composition_constraint_group or fungibility_exception is set)
  - Liquid Allocation Constraints section (shown only for liquid allocations)
  - Draft warning message: "Draft allocations cannot be consumed and do not issue vouchers"
  - Before You Create section with guidance on both creation options
  - Two submit actions via custom getWizardSubmitActions() returning Blade component:
    - "Create as Draft" (primary button) - creates allocation in Draft status
    - "Create and Activate" (success button, role-based) - creates and immediately activates
  - AllocationPolicy with `activate` permission for role-based button visibility using @can directive
  - AfterCreate hook calls AllocationService::activate() when shouldActivateAfterCreate is true
  - Filament Notification messages for both success paths and activation failure
- **Learnings for future iterations:**
  - Custom wizard submit buttons can be implemented by returning HtmlString from getWizardSubmitActions() with Blade::render()
  - Use Livewire wire:click="methodName" to call page methods from custom buttons
  - For role-based actions in wizards, use @can directive with policy
  - Policies for models in subdirectories (App\Models\Allocation\Allocation) need explicit registration in AppServiceProvider using Gate::policy()
  - Property $shouldActivateAfterCreate pattern works for tracking button-specific behavior across create() and afterCreate()
---

## 2026-02-03 - US-013
- What was implemented: Allocation Detail view with 6 tabs organized using Filament Infolist Tabs
- Files changed:
  - `app/Filament/Resources/Allocation/AllocationResource/Pages/ViewAllocation.php` (complete rewrite with tabs)
  - `app/Models/Allocation/Allocation.php` (added auditLogs() morphMany relationship)
- **Features implemented:**
  - Tab 1 - Overview: Status & Identity (allocation ID, UUID, status badges, source type, supply form, serialization), Bottle SKU info, Quantities (total, sold, remaining, available), Availability Window, Lineage Rule explanation
  - Tab 2 - Constraints: Commercial constraints display with Edit link (visible only in Draft), Advanced constraints section (composition group, fungibility exception), Liquid constraints section (for liquid allocations)
  - Tab 3 - Capacity & Consumption: Capacity overview with utilization percentage, Active reservations impact showing reserved vs available quantity, Placeholder for future consumption breakdown by sellable SKU/channel/time (pending Voucher implementation)
  - Tab 4 - Reservations: RepeatableEntry showing all temporary reservations with ID, quantity, context type, status, expires_at, and reference; Summary counts by status (total, active, expired, converted)
  - Tab 5 - Vouchers: Placeholder for future voucher list (pending US-015+ implementation)
  - Tab 6 - Audit: RepeatableEntry showing auditLogs with event badge, user, timestamp, and formatted changes
  - Header Actions: Activate (visible for Draft, role-based), Close (visible for Active/Exhausted, role-based), Edit, More (Delete/Restore)
- **Learnings for future iterations:**
  - Use `Tabs::make()->tabs([...])` with separate methods for each Tab for clean organization
  - Use `->persistTabInQueryString()` to preserve active tab in URL
  - Tab badges can show counts with `->badge(fn () => ...)` and `->badgeColor()`
  - Use `RepeatableEntry::make('relationshipName')` to display hasMany relationships in infolist
  - TextEntry `->getStateUsing()` allows computed values; use service calls for business logic
  - Sections support `->headerActions([...])` for inline action buttons
  - AuditLog polymorphic relationship uses `morphMany(\App\Models\AuditLog::class, 'auditable')`
  - Authorization on header actions: `->authorize('policyMethod', $record)`
---

## 2026-02-03 - US-014
- What was implemented: Allocation status transitions with audit logging and user-friendly validation
- Files changed:
  - `app/Services/Allocation/AllocationService.php` (enhanced with audit logging and transition methods)
- **Features implemented:**
  - `logStatusTransition()` - protected method to create AuditLog entries for status changes
  - `transitionTo()` - generic transition method with comprehensive error messages
  - `canTransitionTo()` - helper method to check if transition is valid
  - All status transitions (activate, close, markAsExhausted, auto-exhausted) now log audit entries
  - Audit entries include: event type (status_change), old_values (status, label), new_values (status, label), user_id, timestamp
  - Enhanced error messages explain allowed transitions and provide guidance
- **Learnings for future iterations:**
  - Use AuditLog::EVENT_STATUS_CHANGE constant for status transition events
  - Always capture $oldStatus BEFORE changing $allocation->status
  - Auth::id() returns current user ID for audit logging
  - Constraint editing protection is already handled by model boot events (AllocationConstraint and LiquidAllocationConstraint)
  - For comprehensive error messages, use allowedTransitions() to show valid options
---

## 2026-02-03 - US-015
- What was implemented: Voucher model as atomic customer entitlement for Module A
- Files changed:
  - `database/migrations/2026_02_03_290000_create_customers_table.php` (new) - placeholder for Module K
  - `database/migrations/2026_02_03_300000_create_vouchers_table.php` (new)
  - `app/Models/Customer/Customer.php` (new) - placeholder for Module K
  - `app/Models/Allocation/Voucher.php` (new)
  - `app/Models/Allocation/Allocation.php` (added vouchers() relationship)
- **Features implemented:**
  - Voucher model with all required fields: customer_id, allocation_id, wine_variant_id, format_id, sellable_sku_id (nullable), quantity (always 1), lifecycle_state, tradable, giftable, suspended, sale_reference, created_by
  - BelongsTo relationships: Customer, Allocation, WineVariant, Format, SellableSku
  - HasMany vouchers() relationship added to Allocation model
  - Quantity=1 invariant enforced in both creating and saving boot events
  - allocation_id immutability enforced in updating boot event (lineage protection)
  - Lifecycle state helper methods: isIssued(), isLocked(), isRedeemed(), isCancelled(), isTerminal()
  - Behavioral flag helpers: canBeTradedOrTransferred(), canBeGifted()
  - UI display helpers: getBottleSkuLabel(), getLifecycleStateLabel(), getLifecycleStateColor(), getLifecycleStateIcon()
  - AuditLog morphMany relationship for future audit trail
- **Learnings for future iterations:**
  - Voucher uses wine_variant_id + format_id as bottle SKU reference (no BottleSku model) - consistent with Allocation
  - Customer model created as placeholder in `app/Models/Customer/` - will be enhanced by Module K
  - Voucher lifecycle states are constants (enum will be added in US-016)
  - Immutability can be enforced via updating boot event with isDirty() check
  - Voucher only has created_by (no updated_by) since most fields are immutable or controlled by services
---

## 2026-02-03 - US-016
- What was implemented: VoucherLifecycleState enum for voucher lifecycle management
- Files changed:
  - `app/Enums/Allocation/VoucherLifecycleState.php` (new)
  - `app/Models/Allocation/Voucher.php` (updated to use enum)
- **Features implemented:**
  - Enum with 4 states: Issued, Locked, Redeemed, Cancelled
  - Terminal states: Redeemed, Cancelled (isTerminal() returns true)
  - Valid transitions: issued→locked, issued→cancelled, locked→redeemed, locked→issued (unlock)
  - Filament-compatible helpers: label(), color(), icon()
  - Transition helpers: allowedTransitions(), canTransitionTo()
  - State behavior helpers: isTerminal(), isActive(), allowsTrading(), allowsFlagModification()
  - description() method for UI state explanation
  - Voucher model updated: removed string constants, added enum cast, updated all helper methods to use enum
  - Added model methods: canTransitionTo(), getAllowedTransitions() for transition logic at model level
- **Learnings for future iterations:**
  - When converting string constants to enums, update: imports, casts, all comparison checks, and helper methods
  - Enum methods can delegate logic (e.g., model.isTerminal() → model.lifecycle_state.isTerminal())
  - Add allowsTrading() to VoucherLifecycleState since trading is only allowed in Issued state
  - description() method useful for UI tooltips and explanatory text
---

## 2026-02-03 - US-017
- What was implemented: CaseEntitlement model for grouping vouchers when a customer buys a fixed case
- Files changed:
  - `database/migrations/2026_02_03_310000_create_case_entitlements_table.php` (new)
  - `database/migrations/2026_02_03_320000_add_case_entitlement_id_to_vouchers_table.php` (new)
  - `app/Enums/Allocation/CaseEntitlementStatus.php` (new)
  - `app/Models/Allocation/CaseEntitlement.php` (new)
  - `app/Models/Allocation/Voucher.php` (added case_entitlement_id and relationship)
- **Features implemented:**
  - CaseEntitlement model with: customer_id, sellable_sku_id, status (enum), broken_at, broken_reason
  - CaseEntitlementStatus enum with Intact and Broken states
  - Enum helpers: label(), color(), icon(), canBeBroken(), isBroken(), isIntact()
  - CaseEntitlement relationships: belongsTo Customer, belongsTo SellableSku, hasMany Voucher
  - CaseEntitlement helpers: isIntact(), isBroken(), canBeBroken(), getVouchersCount(), checkIntegrity()
  - Voucher model: added case_entitlement_id to fillable, caseEntitlement() relationship
  - Voucher helpers: isPartOfCase(), isPartOfIntactCase()
- **Learnings for future iterations:**
  - CaseEntitlement does NOT use soft deletes (once created, it exists permanently for audit trail)
  - The break logic is NOT implemented yet in boot events - it will be triggered by CaseEntitlementService (US-020)
  - checkIntegrity() method can be used to verify case integrity before operations
  - Break reason values will be: 'transfer', 'trade', 'partial_redemption' (to be enforced by service)
---

## 2026-02-03 - US-018
- What was implemented: VoucherTransfer model for tracking transfers of vouchers between customers
- Files changed:
  - `database/migrations/2026_02_03_330000_create_voucher_transfers_table.php` (new)
  - `app/Enums/Allocation/VoucherTransferStatus.php` (new) - pending, accepted, cancelled, expired
  - `app/Models/Allocation/VoucherTransfer.php` (new)
  - `app/Models/Allocation/Voucher.php` (added voucherTransfers relationships)
- **Features implemented:**
  - VoucherTransfer model with: voucher_id, from_customer_id, to_customer_id, status, initiated_at, expires_at, accepted_at, cancelled_at
  - VoucherTransferStatus enum with 4 states and transition helpers (isPending, isAccepted, canBeCancelled, canBeAccepted, isTerminal)
  - BelongsTo relationships: voucher(), fromCustomer(), toCustomer()
  - Scopes: pending(), needsExpiration(), forVoucher(), fromCustomer(), toCustomer()
  - Status helpers: isPending(), isAccepted(), isTerminal(), hasExpired(), canBeCancelled(), canBeAccepted()
  - UI helpers: getStatusLabel(), getStatusColor(), getStatusIcon(), getStatusDescription()
  - Voucher model: added voucherTransfers(), pendingTransfers(), hasPendingTransfer(), getPendingTransfer()
- **Learnings for future iterations:**
  - Transfer does NOT create a new voucher - it only changes voucher.customer_id on acceptance
  - Transfer does NOT consume allocation - it's a customer-to-customer operation
  - VoucherTransfer does NOT use soft deletes (transfers are immutable once created)
  - Only one pending transfer per voucher at a time (enforced by unique index where status = 'pending')
  - The actual transfer logic (accept, cancel, expire) will be implemented in VoucherTransferService (US-021)
  - needsExpiration() scope can be used by a scheduled job to expire pending transfers
---

## 2026-02-03 - US-019
- What was implemented: VoucherService for centralizing voucher business logic
- Files changed:
  - `app/Services/Allocation/VoucherService.php` (new)
  - `app/Models/AuditLog.php` (added new event type constants)
- **Methods implemented:**
  - `issueVouchers(Allocation, Customer, SellableSku, saleReference, quantity)`: Creates vouchers and consumes allocation atomically using AllocationService
  - `lockForFulfillment(Voucher)`: issued → locked transition with validation
  - `unlock(Voucher)`: locked → issued transition with validation
  - `redeem(Voucher)`: locked → redeemed transition (terminal state)
  - `cancel(Voucher)`: issued → cancelled transition (terminal state)
  - `suspend(Voucher, reason)`: Sets suspended=true with optional reason
  - `reactivate(Voucher)`: Sets suspended=false (unsuspend)
  - `setTradable(Voucher, bool)`: Updates tradable flag with validation
  - `setGiftable(Voucher, bool)`: Updates giftable flag with validation
  - `transitionTo(Voucher, VoucherLifecycleState)`: Generic transition method
- **AuditLog event types added:**
  - EVENT_LIFECYCLE_CHANGE: For voucher lifecycle state transitions
  - EVENT_FLAG_CHANGE: For behavioral flag changes (tradable, giftable)
  - EVENT_VOUCHER_ISSUED: For voucher issuance
  - EVENT_VOUCHER_SUSPENDED: For voucher suspension
  - EVENT_VOUCHER_REACTIVATED: For voucher reactivation
- **Learnings for future iterations:**
  - VoucherService injects AllocationService for allocation consumption during issuance
  - Suspended vouchers block ALL operations (lifecycle transitions, flag modifications)
  - Tradable/giftable flags can only be modified on issued vouchers (not locked)
  - Cancel does NOT return quantity to allocation - it's a soft cancellation
  - All lifecycle transitions and flag changes are logged to AuditLog with old/new values
  - validateNotSuspended() helper centralizes suspension check for multiple methods
---

## 2026-02-03 - US-020
- What was implemented: CaseEntitlementService for centralizing case entitlement business logic
- Files changed:
  - `app/Services/Allocation/CaseEntitlementService.php` (new)
- **Methods implemented:**
  - `createFromVouchers(array|Collection vouchers, Customer, SellableSku)`: Creates CaseEntitlement and associates vouchers with comprehensive validation (same customer, not already in case, not terminal)
  - `breakEntitlement(CaseEntitlement, reason)`: Irreversible status transition to Broken, sets broken_at timestamp and broken_reason, logs audit event
  - `isIntact(CaseEntitlement)`: Verifies case status is intact AND all vouchers pass checkIntegrity (same holder, none redeemed)
  - `breakIfVoucherInCase(Voucher, reason)`: Helper for automatic case break when voucher operations occur
  - `getIntactCaseCountForCustomer(Customer)`: Utility for counting intact cases
  - `getCaseEntitlementsForCustomer(Customer)`: Utility for listing all case entitlements
- **Constants defined:**
  - REASON_TRANSFER: 'transfer' - for voucher transfers
  - REASON_TRADE: 'trade' - for external trading
  - REASON_PARTIAL_REDEMPTION: 'partial_redemption' - for redeeming individual vouchers from case
- **Learnings for future iterations:**
  - CaseEntitlementService should be called by VoucherService/VoucherTransferService via breakIfVoucherInCase() when operations would break case integrity
  - The actual automatic trigger integration (US-029) will connect VoucherService lifecycle transitions and VoucherTransferService acceptance to breakIfVoucherInCase()
  - Use Collection or array for voucher input, service handles both types
  - Break is completely irreversible - there's no restore/unbreak operation
  - Voucher model's id IS the UUID (due to HasUuid trait), no separate uuid column exists
---

## 2026-02-03 - US-021
- What was implemented: VoucherTransferService for managing voucher transfers (gifting) between customers
- Files changed:
  - `app/Services/Allocation/VoucherTransferService.php` (new)
  - `app/Jobs/Allocation/ExpireTransfersJob.php` (new)
  - `app/Models/AuditLog.php` (added transfer event constants)
  - `routes/console.php` (registered ExpireTransfersJob scheduled job)
- **Methods implemented:**
  - `initiateTransfer(Voucher, Customer, Carbon)`: Creates pending transfer with comprehensive validation (voucher must be issued, not suspended, not have pending transfer, must be giftable)
  - `acceptTransfer(VoucherTransfer)`: Updates voucher.customer_id to recipient, breaks CaseEntitlement if voucher is part of one, validates voucher not locked/suspended/terminal
  - `cancelTransfer(VoucherTransfer)`: Status → cancelled with audit logging
  - `expireTransfer(VoucherTransfer)`: Expires a single transfer
  - `expireTransfers()`: Batch method for scheduled job, returns count of expired transfers
  - `getPendingTransfer(Voucher)`, `hasPendingTransfer(Voucher)`: Helper methods
- **AuditLog events added:**
  - EVENT_TRANSFER_INITIATED, EVENT_TRANSFER_ACCEPTED, EVENT_TRANSFER_CANCELLED, EVENT_TRANSFER_EXPIRED
- **Learnings for future iterations:**
  - VoucherTransferService injects CaseEntitlementService for automatic case breaking on transfer acceptance
  - Transfer validation checks: issued state, not suspended, not locked, no pending transfer, giftable flag
  - acceptTransfer uses DB::transaction() for atomic update of voucher.customer_id + transfer status
  - Audit logs are created on BOTH the Voucher and VoucherTransfer models for complete audit trail
  - ExpireTransfersJob follows same pattern as ExpireReservationsJob, scheduled every minute
---

## 2026-02-03 - US-022
- What was implemented: VoucherResource in Filament for voucher list as entry point for customer entitlements
- Files changed:
  - `app/Filament/Resources/Allocation/VoucherResource.php` (new)
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ListVouchers.php` (new)
  - `app/Filament/Resources/Allocation/VoucherResource/Pages/ViewVoucher.php` (new - placeholder for US-023)
- **Features implemented:**
  - Navigation group 'Vouchers' with ticket icon, navigation sort 1
  - All required columns: id (copyable), customer (with link to customer view), bottle_sku (computed), sellable_sku, allocation_id (with link to allocation view), lifecycle_state (badge), flags (combined badge), created_at
  - Filters: lifecycle_state (multi-select, default excludes Redeemed/Cancelled), allocation (select with search), customer (select with search), suspended (ternary filter), trashed
  - Search: voucher_id, customer name/email, wine name/producer via custom query callbacks
  - NO Create action - canCreate() returns false and ListVouchers has empty getHeaderActions()
  - Eager loading via modifyQueryUsing for customer, wineVariant.wineMaster, format, sellableSku, allocation
- **Learnings for future iterations:**
  - Use `canCreate(): bool` returning false to disable create functionality in Filament resource
  - TernaryFilter is good for boolean fields with "all/true/false" options
  - Combined flags badge uses state() callback with manual formatting and separator
  - Customer link uses route() helper to link to customer resource view page
---
